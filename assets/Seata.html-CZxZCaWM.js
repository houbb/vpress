import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as i}from"./app-NomDibRt.js";const l="/vpress/images/spring/springboot/25-4.jpg",p="/vpress/images/spring/springboot/25-3.jpg",t="/vpress/images/spring/springboot/25-1.jpg",r="/vpress/images/spring/springboot/25-2.jpg",d={};function o(c,s){return i(),a("div",null,s[0]||(s[0]=[e('<h1 id="业务无侵入框架-seata-解决分布式事务" tabindex="-1"><a class="header-anchor" href="#业务无侵入框架-seata-解决分布式事务"><span>业务无侵入框架 Seata， 解决分布式事务</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>事务的原子性和持久性可以确保在一个事务内，更新多条数据，要么都成功，要么都失败。在一个系统内部，我们可以使用数据库事务来保证数据一致性。那如果一笔交易，涉及到跨多个系统、多个数据库的时候，用单一的数据库事务就没办法解决了。</p><p>此时需要引入分布式事务，关于分布式事务市面上有很多解决方案，之前写过一篇文章 <a href="https://mp.weixin.qq.com/s/dlYkcKOqOJr7wMVONV7YPQ" target="_blank" rel="noopener noreferrer">如何解决分布式事务</a>，感兴趣的同学可以看看。</p><p>本文着重讲下阿里的开源框架 -- Seata，目前在github上已经有2万 star了，非常受欢迎！！！</p><h2 id="seata-框架" tabindex="-1"><a class="header-anchor" href="#seata-框架"><span>Seata 框架</span></a></h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li>对业务无侵入：即减少技术架构上的微服务化所带来的分布式事务问题对业务的侵入</li><li>高性能：减少分布式事务解决方案所带来的性能消耗</li></ul><h3 id="at-模式整体机制" tabindex="-1"><a class="header-anchor" href="#at-模式整体机制"><span>AT 模式整体机制</span></a></h3><ul><li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li><li>二阶段： <ul><li>提交异步化，自动异步批量清理回滚日志。</li><li>通过回滚日志，自动生成补偿操作，完成数据回滚。</li></ul></li></ul><h2 id="核心原理" tabindex="-1"><a class="header-anchor" href="#核心原理"><span>核心原理</span></a></h2><p>Seata 的 JDBC 数据源代理通过对业务 SQL 的解析，把业务数据在更新前后的数据镜像组织成回滚日志，利用<code>本地事务</code>的 ACID 特性，将业务数据的更新和回滚日志的写入在同一个<code>本地事务</code>中提交。</p><blockquote><p>这样可以保证，任何提交的业务数据的更新一定有相应的回滚日志存在。</p></blockquote><p>如果 TC 决议要全局回滚，会通知 RM 进行回滚操作，通过 XID 找到对应的回滚日志记录，通过回滚记录生成反向更新 SQL，进行更新回滚操作。</p><p><strong>TCC 模式，不依赖于底层数据资源的事务支持：</strong></p><ul><li>一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。</li><li>二阶段 commit 行为：调用 自定义 的 commit 逻辑。</li><li>二阶段 rollback 行为：调用 自定义 的 rollback 逻辑。</li></ul><p>所谓 TCC 模式，是指支持把 自定义 的分支事务纳入到全局事务的管理中。</p><h2 id="seata-流程" tabindex="-1"><a class="header-anchor" href="#seata-流程"><span>Seata 流程</span></a></h2><div align="left"><img src="'+l+`" width="700px"></div><h3 id="组成部分" tabindex="-1"><a class="header-anchor" href="#组成部分"><span>组成部分</span></a></h3><ul><li><p>事务协调器（TC）：维护全局事务和分支事务的状态，驱动全局提交或回滚。</p></li><li><p>事务管理器（TM）：定义全局事务的范围：开始全局事务，提交或回滚全局事务。</p></li><li><p>资源管理器（RM）：管理正在处理的分支事务的资源，与TC对话以注册分支事务并报告分支事务的状态，并驱动分支事务的提交或回滚。</p></li></ul><h3 id="事务流程" tabindex="-1"><a class="header-anchor" href="#事务流程"><span>事务流程</span></a></h3><ul><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID</li><li>XID 在微服务调用链路的上下文中传播</li><li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ul><h2 id="代码演示" tabindex="-1"><a class="header-anchor" href="#代码演示"><span>代码演示</span></a></h2><h3 id="采用docker模式-安装-seata-server" tabindex="-1"><a class="header-anchor" href="#采用docker模式-安装-seata-server"><span>采用Docker模式，安装 Seata Server</span></a></h3><p>拉取镜像：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker pull seataio/seata-server</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>启动实例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>docker run --name  seata-server -p 8091:8091  seataio/seata-server</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="业务场景" tabindex="-1"><a class="header-anchor" href="#业务场景"><span>业务场景</span></a></h3><p><strong>用户购买商品的业务逻辑。整个业务逻辑由3个微服务提供支持：</strong></p><ul><li>仓储服务：对给定的商品扣除库存。</li><li>订单服务：根据采购需求创建订单。</li><li>帐户服务：从用户帐户中扣除余额。</li></ul><p>首先引入pom依赖，spring boot 提供了开箱即用的starter组件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;io.seata&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;1.0.0&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构建了四个独立的微服务工程，系统间通过restful接口调用，满足业务需求</p><table><thead><tr><th>工程</th><th>说明</th><th>地址</th></tr></thead><tbody><tr><td>spring-boot-bulking-seata-business</td><td>主业务入口</td><td><a href="http://127.0.0.1:8090/api/business/purchase/commit" target="_blank" rel="noopener noreferrer">http://127.0.0.1:8090/api/business/purchase/commit</a></td></tr><tr><td>spring-boot-bulking-seata-storage</td><td>库存服务</td><td><a href="http://127.0.0.1:8083/api/storage/deduct?commodityCode=6666&amp;count=1" target="_blank" rel="noopener noreferrer">http://127.0.0.1:8083/api/storage/deduct?commodityCode=6666&amp;count=1</a></td></tr><tr><td>spring-boot-bulking-seata-order</td><td>订单服务</td><td><a href="http://127.0.0.1:8082/api/order/debit?userId=101&amp;commodityCode=6666&amp;&amp;count=1" target="_blank" rel="noopener noreferrer">http://127.0.0.1:8082/api/order/debit?userId=101&amp;commodityCode=6666&amp;&amp;count=1</a></td></tr><tr><td>spring-boot-bulking-seata-account</td><td>账户服务</td><td><a href="http://127.0.0.1:8081/account/debit?userId=101&amp;orderMoney=10" target="_blank" rel="noopener noreferrer">http://127.0.0.1:8081/account/debit?userId=101&amp;orderMoney=10</a></td></tr></tbody></table><p>各系统间的交互如下图所示：</p><div align="left"><img src="`+p+`" width="700px"></div><p>针对storage、order、account三个微服务创建3个数据库，并在不同的库中创建对应的业务表，如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>数据库：db_seata_1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>create table account (</span></span>
<span class="line"><span>\`id\` bigint(20) NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>\`user_id\` varchar(255) NOT NULL ,</span></span>
<span class="line"><span>\`money\` int(11)  DEFAULT 0 ,</span></span>
<span class="line"><span>PRIMARY KEY (\`id\`)</span></span>
<span class="line"><span>) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&#39;账户表&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>insert into account(id,user_id,money) value (1,&quot;101&quot;,500);</span></span>
<span class="line"><span>insert into account(id,user_id,money) value (2,&quot;102&quot;,500);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>数据库：db_seata_2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>create table \`order\`(</span></span>
<span class="line"><span>\`id\` bigint(20) NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>\`user_id\` varchar(255) NOT NULL ,</span></span>
<span class="line"><span>\`commodity_code\` varchar(255) ,</span></span>
<span class="line"><span>\`count\` int(11) default 0,</span></span>
<span class="line"><span>\`money\` int(11) default 0,</span></span>
<span class="line"><span>PRIMARY KEY (\`id\`)</span></span>
<span class="line"><span>) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&#39;订单表&#39; ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>数据库：db_seata_3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>create table storage(</span></span>
<span class="line"><span>\`id\` bigint(20) NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>\`commodity_code\` varchar(255) default  null,</span></span>
<span class="line"><span>\`count\` int(11) default 0,</span></span>
<span class="line"><span>PRIMARY KEY (\`id\`),</span></span>
<span class="line"><span>unique key (\`commodity_code\`)</span></span>
<span class="line"><span>) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&#39;库存表&#39; ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>insert into storage(id,commodity_code,count) value (1,&#39;6666&#39;,1000)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>undo_log</code>回滚日志表，功能特殊，seata框架主要借助该表完成事务数据的回滚。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE \`undo_log\` (</span></span>
<span class="line"><span>  \`id\` bigint(20) NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>  \`branch_id\` bigint(20) NOT NULL,</span></span>
<span class="line"><span>  \`xid\` varchar(100) NOT NULL,</span></span>
<span class="line"><span>  \`context\` varchar(128) NOT NULL,</span></span>
<span class="line"><span>  \`rollback_info\` longblob NOT NULL,</span></span>
<span class="line"><span>  \`log_status\` int(11) NOT NULL,</span></span>
<span class="line"><span>  \`log_created\` datetime NOT NULL,</span></span>
<span class="line"><span>  \`log_modified\` datetime NOT NULL,</span></span>
<span class="line"><span>  \`ext\` varchar(100) DEFAULT NULL,</span></span>
<span class="line"><span>  PRIMARY KEY (\`id\`),</span></span>
<span class="line"><span>  UNIQUE KEY \`ux_undo_log\` (\`xid\`,\`branch_id\`)</span></span>
<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>db_seata_1</code>、<code>db_seata_2</code>、<code>db_seata_3</code>，每个数据库都要创建一张<code>undo_log</code>表。</p></blockquote><p>三个工程的<code>application.properties</code>配置项相似，以<code>account</code>工程为例，内容如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>spring.application.name=spring-boot-bulking-seata-account</span></span>
<span class="line"><span>server.port=8081</span></span>
<span class="line"><span>spring.datasource.url=jdbc:mysql://127.0.0.1:3306/db_seata_1?useSSL=false&amp;serverTimezone=UTC</span></span>
<span class="line"><span>spring.datasource.username=root</span></span>
<span class="line"><span>spring.datasource.password=111111</span></span>
<span class="line"><span>mybatis.mapper-locations=classpath*:mapper/*Mapper.xml</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>seata.tx-service-group=my_test_tx_group</span></span>
<span class="line"><span>seata.service.grouplist=127.0.0.1:8091</span></span>
<span class="line"><span>logging.level.io.seata=info</span></span>
<span class="line"><span>logging.level.io.seata.samples.account.persistence.AccountMapper=debug</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>BusinessController</code>提供了两个API入口，模拟下单成功、下单异常回滚</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@GlobalTransactional</span></span>
<span class="line"><span>public void purchase(String userId, String commodityCode, int orderCount) {</span></span>
<span class="line"><span>    LOGGER.info(&quot;purchase begin ... ， xid: &quot; + RootContext.getXID());</span></span>
<span class="line"><span>    // 扣减库存</span></span>
<span class="line"><span>    storageClient.deduct(commodityCode, orderCount);</span></span>
<span class="line"><span>    // 创建订单</span></span>
<span class="line"><span>    orderClient.create(userId, commodityCode, orderCount);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法上添加<code>@GlobalTransactional</code>，描述启动全局性事务</p><p>以扣减库存为例，我们使用Spring框架的<code>RestTemplate</code>，通过Http接口访问远程服务，跨系统如何传递事务标识 XID？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Component</span></span>
<span class="line"><span>public class StorageClient {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Autowired</span></span>
<span class="line"><span>    private RestTemplate restTemplate;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    private static String storageURL = &quot;http://127.0.0.1:8083/api/storage/deduct?commodityCode=%s&amp;count=%s&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void deduct(String commodityCode, int orderCount) {</span></span>
<span class="line"><span>        System.out.println(&quot;invoke storage， xid: &quot; + RootContext.getXID());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        String url = String.format(storageURL, commodityCode, orderCount);</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            ResponseEntity&lt;String&gt; result = restTemplate.getForEntity(url, String.class);</span></span>
<span class="line"><span>            System.out.println(&quot;[StorageClient] invoke，result=&quot; + result.getBody());</span></span>
<span class="line"><span>        } catch (Exception e) {</span></span>
<span class="line"><span>            log.error(&quot;deduct url {} ,error:&quot;, url, e);</span></span>
<span class="line"><span>            throw new RuntimeException();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们重写了<code>ClientHttpRequestInterceptor</code>拦截器，并注入到<code>RestTemplate</code>实例中。每次发送Http请求时，从<code>ThreadLocal</code>取到XID写入Header，然后再将请求发送给目标端。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Component</span></span>
<span class="line"><span>public class RestTemplateInterceptor implements ClientHttpRequestInterceptor {</span></span>
<span class="line"><span>  </span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public ClientHttpResponse intercept(HttpRequest httpRequest, byte[] bytes, ClientHttpRequestExecution clientHttpRequestExecution) throws IOException {</span></span>
<span class="line"><span>        HttpRequestWrapper requestWrapper = new HttpRequestWrapper(httpRequest);</span></span>
<span class="line"><span>        String xid = RootContext.getXID();</span></span>
<span class="line"><span>        if (StringUtils.isNotEmpty(xid)) {</span></span>
<span class="line"><span>            requestWrapper.getHeaders().add(RootContext.KEY_XID, xid);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return clientHttpRequestExecution.execute(requestWrapper, bytes);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="case-测试" tabindex="-1"><a class="header-anchor" href="#case-测试"><span>Case 测试</span></a></h3><p>Seata事务无论成功或者回滚，都会物理删除<code>undo_log</code>表里的记录，为了验证中间过程，我们在下游Order系统里的<code>com.weiguanjishu.service.OrderService#create</code>设置个断点，临时中断请求，然后查看各个表的数据变化</p><div align="left"><img src="`+t+'" width="700px"></div><p>然后将断点放开，请求处理成功，再来看下各表的数据情况</p><div align="left"><img src="'+r+`" width="700px"></div><p><strong>写在最后</strong></p><blockquote><p>Seata 与其它分布式事务最大的区别在于，它在第一提交阶段就已经将各个分支事务操作 commit 了。Seata 认为在一个正常的业务下，各个服务提交事务的大概率是成功的，这种事务提交操作可以节约两个阶段持有锁的时间，从而提高整体的执行效率。</p></blockquote><h2 id="项目源码" tabindex="-1"><a class="header-anchor" href="#项目源码"><span>项目源码</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://github.com/aalansehaiyang/spring-boot-bulking  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>子模块：</span></span>
<span class="line"><span>spring-boot-bulking-seata-business</span></span>
<span class="line"><span>spring-boot-bulking-seata-storage</span></span>
<span class="line"><span>spring-boot-bulking-seata-order</span></span>
<span class="line"><span>spring-boot-bulking-seata-account</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><ul><li><a href="https://mp.weixin.qq.com/s/9aZIGLJx7W9b51QA91fGLw" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/9aZIGLJx7W9b51QA91fGLw</a></li><li><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener noreferrer">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li><li><a href="https://blog.csdn.net/hosaos/article/details/89136666" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/hosaos/article/details/89136666</a></li><li><a href="http://seata.io/zh-cn/docs/overview/what-is-seata.html" target="_blank" rel="noopener noreferrer">http://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li></ul>`,66)]))}const h=n(d,[["render",o]]),v=JSON.parse('{"path":"/posts/interview/spring/springboot/Seata.html","title":"业务无侵入框架 Seata， 解决分布式事务","lang":"zh-CN","frontmatter":{"title":"业务无侵入框架 Seata， 解决分布式事务","description":"业务无侵入框架 Seata， 解决分布式事务 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/spring/springboot/Seata.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"业务无侵入框架 Seata， 解决分布式事务"}],["meta",{"property":"og:description","content":"业务无侵入框架 Seata， 解决分布式事务 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"业务无侵入框架 Seata， 解决分布式事务\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":7.33,"words":2200},"filePathRelative":"posts/interview/spring/springboot/Seata.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p>","autoDesc":true}');export{h as comp,v as data};
