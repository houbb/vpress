import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as t,o as s}from"./app-NomDibRt.js";const d="/vpress/images/middleware/mysql/5-1.jpg",a="/vpress/images/middleware/mysql/5-2.jpg",r="/vpress/images/middleware/mysql/5-3.jpg",p="/vpress/images/middleware/mysql/5-4.jpg",l="/vpress/images/middleware/mysql/5-5.jpg",c={};function n(h,e){return s(),o("div",null,e[0]||(e[0]=[t('<h1 id="mysql-主从延迟-7-种解决方案" tabindex="-1"><a class="header-anchor" href="#mysql-主从延迟-7-种解决方案"><span>MySQL 主从延迟 7 种解决方案</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>我们都知道互联网数据有个特性，大部分场景都是 <code>读多写少</code>，比如：微博、微信、淘宝电商，按照 <code>二八原则</code>，读流量占比甚至能达到 90%</p><p>结合这个特性，我们对底层的数据库架构也会做相应调整。采用 <code>读写分离</code></p><div align="left"><img src="'+d+'" width="650px"></div><p><strong>处理过程：</strong></p><ul><li>客户端会集成 SDK，每次执行 SQL 时，会判断是 <code>写</code> 或 <code>读</code> 操作</li><li>如果是 <code>写</code> SQL，请求会发到 <code>主库</code></li><li>主数据库执行SQL，事务提交后，会生成 <code>binlog</code> ，并同步给 <code>从库</code></li><li><code>从库</code> 通过 SQL 线程回放 <code>binlog</code> ，并在从库表中生成相应数据</li><li>如果是 <code>读</code> SQL，请求会通过 <code>负载均衡</code> 策略，挑选一个 <code>从库</code> 处理用户请求</li></ul><p>看似非常合理，细想却不是那么回事</p><p><code>主库</code> 与 <code>从库</code> 是采用异步复制数据，如果这两者之间数据还没有同步怎么办？</p><p>主库刚写完数据，从库还没来得及拉取最新数据，<code>读</code> 请求就来了，给用户的感觉，<code>数据丢了？？？</code></p><div align="left"><img src="'+a+`" width="260px"></div><p>针对这个问题，今天，我们就来探讨下有什么解决方案？</p><h2 id="一、强制走主库" tabindex="-1"><a class="header-anchor" href="#一、强制走主库"><span>一、强制走主库</span></a></h2><p>针对不用的业务诉求，区别性对待</p><p><strong>场景一：</strong></p><p>如果是对数据的 <code>实时性</code> 要求不是很高，比如：大V有千万粉丝，发布一条微博，粉丝晚几秒钟收到这条信息，并不会有特别大的影响。这时，可以走 <code>从库</code>。</p><p><strong>场景二：</strong></p><p>如果对数据的 <code>实时性</code> 要求非常高，比如金融类业务。我们可以在客户端代码标记下，让查询强制走主库。</p><h2 id="二、从库延迟查询" tabindex="-1"><a class="header-anchor" href="#二、从库延迟查询"><span>二、从库延迟查询</span></a></h2><p>由于主从库之间数据同步需要一定的时间间隔，那么有一种策略是延迟从从库查询数据。</p><p>比如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select sleep(1)</span></span>
<span class="line"><span>select * from order where order_id=11111;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>在正式的业务查询时，先执行一个sleep 语句，给从库预留一定的数据同步缓冲期。</p><p>因为是采用一刀切，当面对高并发业务场景时，性能会下降的非常厉害，一般不推荐这个方案。</p><h2 id="三、判断主从是否延迟-决定选主库还是从库" tabindex="-1"><a class="header-anchor" href="#三、判断主从是否延迟-决定选主库还是从库"><span>三、判断主从是否延迟？决定选主库还是从库</span></a></h2><p>之前写过一篇文章 <a href="https://mp.weixin.qq.com/s/SHuYEQ04HzV8TSpldDafRQ" target="_blank" rel="noopener noreferrer">《京东一面：MySQL 主备延迟有哪些坑？主备切换策略<br> 》</a></p><p>有讲过 <code>什么是主备延迟？</code>、<code>主备延迟的常见原因？</code></p><p><strong>方案一：</strong></p><p>在从库 执行 命令 <code>show slave status</code></p><p>查看 <code>seconds_behind_master</code> 的值，单位为秒，如果为 0，表示主备库之间无延迟</p><p><strong>方案二：</strong></p><p>比较主从库的文件点位</p><p>还是执行 <code>show slave status</code>，响应结果里有截个关键参数</p><ul><li>Master_Log_File 读到的主库最新文件</li><li>Read_Master_Log_Pos 读到的主库最新文件的坐标位置</li><li>Relay_Master_Log_File 从库执行到的最新文件</li><li>Exec_Master_Log_Pos 从库执行到的最新文件的坐标位置</li></ul><p>两两比较，上面的参数是否相等</p><p><strong>方案三：</strong></p><p>比较 GTID 集合</p><ul><li>Auto_Position=1 主从之间使用 GTID 协议</li><li>Retrieved_Gtid_Set 从库收到的所有binlog日志的 GTID 集合</li><li>Executed_Gtid_Set 从库已经执行完成的 GTID 集合</li></ul><p>比较 <code>Retrieved_Gtid_Set</code> 和 <code>Executed_Gtid_Set</code> 的值是否相等</p><p>在执行业务SQL操作时，先判断从库是否已经同步最新数据。从而决定是操作主库，还是操作从库。</p><p><strong>缺点：</strong></p><p>无论采用上面哪一种方案，如果主库的写操作频繁不断，那么从库的值永远跟不上主库的值，那么读流量永远是打在了主库上。</p><p><strong>针对这个问题，有什么解决方案？</strong></p><p>这个问题跟 MQ消息队列 既要求高吞吐量又要保证顺序是一样的，从全局来看确实无解，但是缩小范围就容易多了，我们可以保证一个分区内的消息有序。</p><p>回到 <code>主从库</code> 之间的数据同步问题，从库查询哪条记录，我们只要保证之前对应的写binglog已经同步完数据即可，可以不用管主从库的所有的事务binlog 是否同步。</p><p>问题是不是一下简单多了</p><div align="left"><img src="`+r+'" width="260px"></div><h2 id="四、从库节点判断主库位点" tabindex="-1"><a class="header-anchor" href="#四、从库节点判断主库位点"><span>四、从库节点判断主库位点</span></a></h2><p>在从库执行下面命令，返回是一个正整数 M，表示从库从参数节点开始执行了多少个事务</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select master_pos_wait(file, pos[, timeout]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>file 和 pos 表示主库上的文件名和位置</li><li>timeout 可选， 表示这个函数最多等待 N 秒</li></ul><p><strong>缺点：</strong></p><p><code>master_pos_wait</code> 返回结果无法与具体操作的数据行做关联，所以每次接收<code>读请求</code>时，从库还是无法确认是否已经同步数据，方案实用性不高。</p><h2 id="五、比较-gtid" tabindex="-1"><a class="header-anchor" href="#五、比较-gtid"><span>五、比较 GTID</span></a></h2><p>执行下面查询命令</p><ul><li>阻塞等待，直到从库执行的事务中包含 gtid_set，返回 0</li><li>超时，返回 1</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select wait_for_executed_gtid_set(gtid_set, 1);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的 GTID 返回给客户端。具体操作，将参数<code>session_track_gtids</code> 设置为<code>OWN_GTID</code>，调用 API 接口<code>mysql_session_track_get_first</code> 返回结果解析出 GTID</p></blockquote><p><strong>处理流程：</strong></p><ul><li>发起 <code>写</code> SQL 操作，在主库成功执行后，返回这个事务的 GTID</li><li>发起 <code>读</code> SQL 操作时，先在从库执行 <code>select wait_for_executed_gtid_set (gtid_set, 1)</code></li><li>如果返回 0，表示已经从库已经同步了数据，可以在从库执行 <code>查询</code> 操作</li><li>否则，在主库执行 <code>查询</code> 操作</li></ul><p><strong>缺点：</strong></p><p>跟上面的 <code>master_pos_wait</code> 类似，如果 <code>写操作</code> 与 <code>读操作</code> 没有上下文关联，那么 GTID 无法传递 。方案实用性不高。</p><h2 id="六、引入缓存中间件" tabindex="-1"><a class="header-anchor" href="#六、引入缓存中间件"><span>六、引入缓存中间件</span></a></h2><div align="left"><img src="'+p+'" width="700px"></div><p>高并发系统，缓存作为性能优化利器，应用广泛。我们可以考虑引入缓存作为<code>缓冲介质</code></p><p><strong>处理过程：</strong></p><ul><li>客户端 <code>写</code> SQL ，操作主库</li><li>同步将缓存中的数据删除</li><li>当客户端读数据时，优先从缓存加载</li><li>如果 缓存中没有，会强制查询主库预热数据</li></ul><p><strong>缺点：</strong></p><p>K-V 存储，适用一些简单的查询条件场景。如果复杂的查询，还是要查询从库。</p><h2 id="七、数据分片" tabindex="-1"><a class="header-anchor" href="#七、数据分片"><span>七、数据分片</span></a></h2><div align="left"><img src="'+l+'" width="700px"></div><p>参考 Redis Cluster 模式， 集群网络拓扑通常是 3主 3从，主节点既负责写，也负责读。</p><p>通过水平分片，支持数据的横向扩展。由于每个节点都是独立的服务器，可以提高整体集群的吞吐量。</p><p>转换到数据库方面</p><p>常见的解决方式，是分库分表，每次<code>读写</code>都是操作主库的一个分表，从库只用来做数据备份。当主库发生故障时，主从切换，保证集群的高可用性。</p>',76)]))}const b=i(c,[["render",n]]),u=JSON.parse('{"path":"/posts/interview/middleware/mysql/MySQL%20%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%207%20%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html","title":"MySQL 主从延迟 7 种解决方案","lang":"zh-CN","frontmatter":{"title":"MySQL 主从延迟 7 种解决方案","description":"MySQL 主从延迟 7 种解决方案 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们都知道互联网数据有个特性，大部分场景都是 读多写少，比如：微博、微信、淘宝电商，按照 二八原则，读流量占比甚至能达到 90% 结合这个特性，我们对底层的数据库架构也会做相应调整。采用 读写分离 处理...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mysql/MySQL%20%E4%B8%BB%E4%BB%8E%E5%BB%B6%E8%BF%9F%207%20%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"MySQL 主从延迟 7 种解决方案"}],["meta",{"property":"og:description","content":"MySQL 主从延迟 7 种解决方案 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们都知道互联网数据有个特性，大部分场景都是 读多写少，比如：微博、微信、淘宝电商，按照 二八原则，读流量占比甚至能达到 90% 结合这个特性，我们对底层的数据库架构也会做相应调整。采用 读写分离 处理..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 主从延迟 7 种解决方案\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":5.95,"words":1785},"filePathRelative":"posts/interview/middleware/mysql/MySQL 主从延迟 7 种解决方案.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>我们都知道互联网数据有个特性，大部分场景都是 <code>读多写少</code>，比如：微博、微信、淘宝电商，按照 <code>二八原则</code>，读流量占比甚至能达到 90%</p>","autoDesc":true}');export{b as comp,u as data};
