import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as r,o as i}from"./app-NomDibRt.js";const n={};function p(o,e){return i(),t("div",null,e[0]||(e[0]=[r('<h1 id="mq-那点破事-消息丢失、重复消费、有序、堆积、事务、高可用" tabindex="-1"><a class="header-anchor" href="#mq-那点破事-消息丢失、重复消费、有序、堆积、事务、高可用"><span>MQ 那点破事！消息丢失、重复消费、有序、堆积、事务、高可用</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="消息队列的应用场景" tabindex="-1"><a class="header-anchor" href="#消息队列的应用场景"><span><strong>消息队列的应用场景？</strong></span></a></h2><p>答案：</p><p>1、异步处理 2、流量削峰填谷 3、应用解耦 4、消息通讯</p><ul><li>异步处理。将一个请求链路中的非核心流程，拆分出来，异步处理，减少主流程链路的处理逻辑，缩短RT，提升吞吐量。如：注册新用户发短信通知。</li><li>削峰填谷。避免流量暴涨，打垮下游系统，前面会加个消息队列，平滑流量冲击。比如：秒杀活动。生活中像电源适配器也是这个原理。</li><li>应用解耦。两个应用，通过消息系统间接建立关系，避免一个系统宕机后对另一个系统的影响，提升系统的可用性。如：下单异步扣减库存</li><li>消息通讯。内置了高效的通信机制，可用于消息通讯。如：点对点消息队列、聊天室。</li></ul><h2 id="消息队列缺点" tabindex="-1"><a class="header-anchor" href="#消息队列缺点"><span>消息队列缺点？</span></a></h2><p>答案：</p><p><strong>1、 系统可用性降低</strong><br> 系统引入的外部依赖越多，越容易挂掉。<br><strong>2、 系统复杂度提高</strong><br> 加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。<br><strong>3、 一致性问题</strong><br> A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这就数据不一致了</p><h2 id="常用的消息框架有哪些" tabindex="-1"><a class="header-anchor" href="#常用的消息框架有哪些"><span><strong>常用的消息框架有哪些？</strong></span></a></h2><p>答案：</p><p>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaQ，RocketMQ、Pulsar 等</p><h2 id="mq技术选型" tabindex="-1"><a class="header-anchor" href="#mq技术选型"><span><strong>MQ技术选型？</strong></span></a></h2><p>答案：</p><p>对比了 Kafka、RocketMQ 、Pulsar 三个框架，时耗、吞吐量、可靠性、事务、副本同步策略、多租户、动态扩容、故障恢复等评估指标。详细内容，参考 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;mid=2247484919&amp;idx=1&amp;sn=9751c0207dac7f0003baad18b0c9adfe&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">为什么放弃Kafka，选择Pulsar?</a></p><h2 id="消息模型有哪些" tabindex="-1"><a class="header-anchor" href="#消息模型有哪些"><span><strong>消息模型有哪些？</strong></span></a></h2><p>答案：</p><p>1、点对点模式</p><p>2、发布/订阅模式</p><h2 id="如何保证-mq-消息不丢失" tabindex="-1"><a class="header-anchor" href="#如何保证-mq-消息不丢失"><span><strong>如何保证 MQ 消息不丢失？</strong></span></a></h2><p>答案：</p><p>在了解消息中间件的运作模式后，主要从三个方面来考虑这个问题：</p><p>1、生产端，不丢失消息</p><p>2、MQ服务端，存储本身不丢失消息</p><p>3、消费端，不丢失消息</p><p>详细内容，参考 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;mid=2247485593&amp;idx=1&amp;sn=6fdd0eb81efc8b4340bcdd39c094af4f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">硬核 | Kafka 如何解决消息不丢失？</a></p><h2 id="如何解决消息的重复消费" tabindex="-1"><a class="header-anchor" href="#如何解决消息的重复消费"><span><strong>如何解决消息的重复消费？</strong></span></a></h2><p>答案：</p><p>生产端为了保证消息发送成功，可能会重复推送（直到收到成功ACK），会产生重复消息。但是一个成熟的MQ Server框架一般会想办法解决，避免存储重复消息（比如：空间换时间，存储已处理过的message_id），给生产端提供一个幂等性的发送消息接口。</p><p>但是消费端却无法根本解决这个问题，在高并发标准要求下，拉取消息+业务处理+提交消费位移需要做事务处理，另外消费端服务可能宕机，很可能会拉取到重复消息。</p><p>所以，只能业务端自己做控制，对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等。</p><h2 id="如何保证-mq消息是有序的" tabindex="-1"><a class="header-anchor" href="#如何保证-mq消息是有序的"><span><strong>如何保证 MQ消息是有序的？</strong></span></a></h2><p>答案：</p><p>有些业务有上下文要求，比如：电商行业的下单、付款、发货、确认收货，每个环节都会发送消息。而消费端拉取并消费消息时，也是希望按正常的状态机流程进行。所以对消息就有了顺序要求。解决思路：</p><ul><li>1、该topic强制采用一个分区，所有消息放到一个队列里，这样能达到全局顺序性。但是会损失高并发特性。</li><li>2、局部有序，采用路由机制，将同一个订单的不同状态消息存储在一个分区partition，单线程消费。比如Kafka就提供了一个接口扩展org.apache.kafka.clients.Partitioner，方便开发人员按照自己的业务场景来定制路由规则。</li><li>详细内容，参考 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;mid=2247485734&amp;idx=1&amp;sn=c3a2cc05b7f79e3dbe74b2162c189c3c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">面试官问：如何保证 MQ消息是有序的？</a></li></ul><h2 id="如何处理消息堆积" tabindex="-1"><a class="header-anchor" href="#如何处理消息堆积"><span><strong>如何处理消息堆积？</strong></span></a></h2><p>答案：</p><p>主要是消息的消费速度跟不上生产速度，从而导致消息堆积。解决思路：</p><ul><li><strong>1、消费者扩容</strong>。可能是刚上线的业务，或者大促活动，流量评估不到位。如果当前Topic的Message Queue的数量大于消费者数量，这时需要增加消费组的机器数量，提升整体消费能力</li><li><strong>2、消息迁移Queue扩容</strong>：如果当前Topic的Message Queue的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容Message Queue。可以新建一个临时的Topic，临时的Topic多设置一些Message Queue，然后先用一些消费者把消费的数据丢到临时的Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的Topic里的数据，消费完了之后，恢复原状。</li><li><strong>3、消费端的代码bug</strong>：正常情况，一条消息处理需要10ms，但是优化不到位或者线上bug，现在要500ms，那么消费端的整体处理速度会下降50倍。这时，我们就要针对性的排查业务代码。老马之前带的团队就有小伙伴出现这个问题，当时是数据库的一条sql没有命中索引，导致单条消息处理耗时拉长，进而导致消息堆积，线上报警，不过凭我们丰富的经验，很快就定位解决了。</li></ul><h2 id="如何保证数据一致性问题" tabindex="-1"><a class="header-anchor" href="#如何保证数据一致性问题"><span><strong>如何保证数据一致性问题？</strong></span></a></h2><p>答案：</p><p>为了解耦，引入异步消息机制。先进行本地数据库操作，处理成功后，再发送MQ消息，由消费端进行后续操作。比如：电商订单下单成功后，要通知扣减库存。</p><p>这两者一定要保证事务操作，否则就会出现数据不一致问题。这时候，我们就需要引入事务消息来解决这个问题。</p><p>另外，在消费环节，也可能出现数据不一致情况。我们可以采用最终一致性原则，增加重试机制。</p><h2 id="事务消息是如何实现" tabindex="-1"><a class="header-anchor" href="#事务消息是如何实现"><span><strong>事务消息是如何实现？</strong></span></a></h2><p>答案：</p><ul><li>1、生产者先发送一条半事务消息到MQ</li><li>2、MQ收到消息后返回ack确认</li><li>3、生产者开始执行本地事务</li><li>4、if 本地事务执行成功，发送commit到MQ；失败，发送rollback</li><li>5、如果MQ⻓时间未收到生产者的二次确认commit或rollback，MQ对生产者发起反向回查</li><li>6、生产者查询事务执行最终状态</li><li>7、根据查询事务状态，再次提交二次确认</li></ul><figure><img src="https://cdn.nlark.com/yuque/0/2022/png/21503536/1666966561705-737f63fe-dd33-46aa-9450-445c54cd6271.png#averageHue=%23f8f8f7&amp;clientId=ua3cd0822-4eec-4&amp;from=paste&amp;height=230&amp;id=ub3277225&amp;originHeight=403&amp;originWidth=1080&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3a84a19b-3ef9-4af6-9b37-3d32ba144a9&amp;title=&amp;width=616" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;mid=2247484829&amp;idx=1&amp;sn=60f39021b58762ea909ea5ae53434945&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">关于分布式事务问题，除了事务消息，还有哪些解决方案？</a></p><h2 id="如何实现高吞吐量" tabindex="-1"><a class="header-anchor" href="#如何实现高吞吐量"><span><strong>如何实现高吞吐量？</strong></span></a></h2><p>答案：</p><ul><li>1、消息的批量处理</li><li>2、消息压缩，节省传输带宽和存储空间</li><li>3、零拷贝</li><li>4、磁盘的顺序写入</li><li>5、page cache 页缓存，由操作系统异步将缓存中的数据刷到磁盘，以及高效的内存读取</li><li>6、分区设计，一个逻辑topic下面挂载N个分区，每个分区可以对应不同的机器消费消息，并发设计。</li></ul><h2 id="如何做到高可用性" tabindex="-1"><a class="header-anchor" href="#如何做到高可用性"><span><strong>如何做到高可用性？</strong></span></a></h2><p>答案：</p><p>以Kafka框架为例，其他的MQ框架原理类似。</p><p>Kafka 由多个 broker 组成，每个 broker 是一个节点。你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 存放在不同的 broker 上，每个 partition 存放一部分数据，每个 partition 有多个 replica 副本。</p><p>写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。</p><p>如果某个 broker 宕机了，没事儿，那个 broker 上面的 partition 在其他机器上都有副本，此时会从 follower 中重新选举一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就是所谓的高可用性。</p><p>更多内容，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;mid=2247484882&amp;idx=1&amp;sn=8dfc206d3d4c34b592b9ed823c314fd3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">关于消息队列，面试官一般都会问哪些？</a></p>',59)]))}const c=a(n,[["render",p]]),h=JSON.parse('{"path":"/posts/interview/interview/tech/MQ%20%E9%82%A3%E7%82%B9%E7%A0%B4%E4%BA%8B.html","title":"第十三篇：MQ 消息队列 ！消息丢失、重复消费、有序、堆积、事务、高可用","lang":"zh-CN","frontmatter":{"title":"第十三篇：MQ 消息队列 ！消息丢失、重复消费、有序、堆积、事务、高可用","description":"MQ 那点破事！消息丢失、重复消费、有序、堆积、事务、高可用 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 消息队列的应用场景？ 答案： 1、异步处理 2、流量削峰填谷 3、应用解耦 4、消息通讯 异步处理。将一个请求链路中的非核心流程，拆分出来，异步处理，减少主流程链路的处理逻辑，缩短RT...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/interview/tech/MQ%20%E9%82%A3%E7%82%B9%E7%A0%B4%E4%BA%8B.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"第十三篇：MQ 消息队列 ！消息丢失、重复消费、有序、堆积、事务、高可用"}],["meta",{"property":"og:description","content":"MQ 那点破事！消息丢失、重复消费、有序、堆积、事务、高可用 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 消息队列的应用场景？ 答案： 1、异步处理 2、流量削峰填谷 3、应用解耦 4、消息通讯 异步处理。将一个请求链路中的非核心流程，拆分出来，异步处理，减少主流程链路的处理逻辑，缩短RT..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.nlark.com/yuque/0/2022/png/21503536/1666966561705-737f63fe-dd33-46aa-9450-445c54cd6271.png#averageHue=%23f8f8f7&clientId=ua3cd0822-4eec-4&from=paste&height=230&id=ub3277225&originHeight=403&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3a84a19b-3ef9-4af6-9b37-3d32ba144a9&title=&width=616"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十三篇：MQ 消息队列 ！消息丢失、重复消费、有序、堆积、事务、高可用\\",\\"image\\":[\\"https://cdn.nlark.com/yuque/0/2022/png/21503536/1666966561705-737f63fe-dd33-46aa-9450-445c54cd6271.png#averageHue=%23f8f8f7&clientId=ua3cd0822-4eec-4&from=paste&height=230&id=ub3277225&originHeight=403&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3a84a19b-3ef9-4af6-9b37-3d32ba144a9&title=&width=616\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":7.65,"words":2294},"filePathRelative":"posts/interview/interview/tech/MQ 那点破事.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2><strong>消息队列的应用场景？</strong></h2>\\n<p>答案：</p>\\n<p>1、异步处理 2、流量削峰填谷 3、应用解耦 4、消息通讯</p>\\n<ul>\\n<li>异步处理。将一个请求链路中的非核心流程，拆分出来，异步处理，减少主流程链路的处理逻辑，缩短RT，提升吞吐量。如：注册新用户发短信通知。</li>\\n<li>削峰填谷。避免流量暴涨，打垮下游系统，前面会加个消息队列，平滑流量冲击。比如：秒杀活动。生活中像电源适配器也是这个原理。</li>\\n<li>应用解耦。两个应用，通过消息系统间接建立关系，避免一个系统宕机后对另一个系统的影响，提升系统的可用性。如：下单异步扣减库存</li>\\n<li>消息通讯。内置了高效的通信机制，可用于消息通讯。如：点对点消息队列、聊天室。</li>\\n</ul>","autoDesc":true}');export{c as comp,h as data};
