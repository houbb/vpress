import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as i,o as s}from"./app-NomDibRt.js";const t="/vpress/images/spring/springboot/6-1.jpg",l={};function p(r,n){return s(),a("div",null,n[0]||(n[0]=[i(`<h1 id="spring-boot-集成-guava" tabindex="-1"><a class="header-anchor" href="#spring-boot-集成-guava"><span>Spring Boot 集成 Guava</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p><p>本地缓存一般位于应用服务器的部署机器上，使用应用服务器本身的少量内存。它是应用层获取数据的第一道缓存，应用层获取数据时先访问本地缓存，如果未命中，再通过远程从 L1 缓存层获取，最终获取到的数据再预热到本地缓存中。</p><p>相比远程缓存，本地缓存离应用和用户设备更近，性能会更好。</p><p>今天，我们主要介绍一款非常流行的本地缓存框架 —— Guava缓存</p><h2 id="什么是-guava" tabindex="-1"><a class="header-anchor" href="#什么是-guava"><span>什么是 Guava</span></a></h2><p>Guava 是 Google 开发的一款 Java 开源框架。</p><p>提供了一些 JDK 没有提供的功能，以及对 JDK 已有功能的增强功能。</p><p>包括：集合（Collections）、缓存（Caching）、原生类型支持（Primitives Support）、并发库（Concurrency Libraries）、通用注解（Common Annotation）、字符串处理（Strings Processing）、数学计算（Math）、I/O、事件总线（EventBus）等等。</p><h2 id="项目集成" tabindex="-1"><a class="header-anchor" href="#项目集成"><span>项目集成</span></a></h2><p>在 pom.xml 文件引入相应的二方包依赖</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;23.0&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化本地缓存类实例，并设置各种参数，满足个性化业务场景需求。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public class LocalCacheService {</span></span>
<span class="line"><span>    // 缓存接口这里是LoadingCache，LoadingCache在缓存项不存在时可以自动加载缓存</span></span>
<span class="line"><span>    public static LoadingCache&lt;Long, User&gt; userCache</span></span>
<span class="line"><span>            = CacheBuilder.newBuilder()</span></span>
<span class="line"><span>            .concurrencyLevel(8)</span></span>
<span class="line"><span>            .expireAfterWrite(5, TimeUnit.SECONDS)</span></span>
<span class="line"><span>            .expireAfterAccess(20, TimeUnit.SECONDS)</span></span>
<span class="line"><span>            .refreshAfterWrite(3, TimeUnit.SECONDS)</span></span>
<span class="line"><span>            .initialCapacity(5)</span></span>
<span class="line"><span>            .maximumSize(10)</span></span>
<span class="line"><span>            .recordStats()</span></span>
<span class="line"><span>            .removalListener(new RemovalListener&lt;Object, Object&gt;() {</span></span>
<span class="line"><span>                @Override</span></span>
<span class="line"><span>                public void onRemoval(RemovalNotification&lt;Object, Object&gt; notification) {</span></span>
<span class="line"><span>                    System.out.println(notification.getKey() + &quot; 被移除了，原因： &quot; + notification.getCause());</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            })</span></span>
<span class="line"><span>            .build(</span></span>
<span class="line"><span>                    new CacheLoader&lt;Long, User&gt;() {</span></span>
<span class="line"><span>                        @Override</span></span>
<span class="line"><span>                        public User load(Long id) throws Exception {</span></span>
<span class="line"><span>                            System.out.println(&quot;缓存未命中，从数据库加载，用户id：&quot; + id);</span></span>
<span class="line"><span>                            return User.builder().id(id).userName(&quot;Lily&quot;).age(new Random().nextInt(20)).build();</span></span>
<span class="line"><span>                        }</span></span>
<span class="line"><span>                    }</span></span>
<span class="line"><span>            );</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>参数解释：</strong></p><ul><li>expireAfterWrite 指定key在一定时间内没有创建/覆盖时，会移除该key，下次取的时候从loading中取</li><li>expireAfterAccess 指定key在一定时间内没有读写，会移除该key，下次取的时候从loading中取</li><li>refreshAfterWrite 指定key在一定时间内没有创建/覆盖时，则指定时间过后，再次访问时，会去刷新该缓存，在新值没有到来之前，始终返回旧值</li></ul><blockquote><p>主要区别：指定时间后，expire 是 remove 该 key，下次访问时同步去获取返回新值。<br><br> 而 refresh 则是指定时间后，不会 remove 该key，下次访问会触发刷新，新值没有拿到前返回旧值</p></blockquote><ul><li>concurrencyLevel(8) 设置并发级别为8，并发级别是指可以同时写缓存的线程数</li><li>initialCapacity(5) 缓存容器的初始容量为5</li><li>maximumSize(10) 缓存最大容量为 10，超过之后就会按照LRU 移除缓存项</li><li>recordStats() 统计缓存的命中率，线上环境一般不需要</li><li>removalListener(new RemovalListener&lt;Object, Object&gt;() 设置缓存的移除通知</li><li>build() 指定CacheLoader，在缓存不存在时通过CacheLoader的实现自动加载缓存</li></ul><p><strong>构造LoadingCache对象，里面提供了很多方法来操作缓存，比如 <code>getIfPresent</code> 、<code>put</code>、<code>invalidate</code>等，详细可以参考下图：</strong></p><div align="left"><img src="`+t+`" width="800px"></div><p><strong>Guava 缓存失效的方法：</strong></p><ul><li>invalidate(key)：废弃缓存中 key对应的 value值。</li><li>invalidateAll()：废弃缓存中所有的value值。</li><li>invalidateAll(Iterable&lt;?&gt; keys)：废弃传入key集合对应的所有缓存中的value值。</li></ul><p><strong>CacheStats 支持的监控统计维度：</strong></p><ul><li>requestCount()：返回Cache的lookup方法查找缓存的次数，不论查找的值是否被缓存。</li><li>hitCount()：返回Cache的lookup方法命中缓存的次数。</li><li>hitRate()：返回缓存请求的命中率，命中次数除以请求次数。</li><li>missCount()：返回缓存请求的未命中的次数。</li><li>missRate()：返回缓存请求未命中的比率，未命中次数除以请求次数。</li><li>loadCount()：返回缓存调用load方法加载新值的次数。</li><li>loadSuccessCount()：返回缓存加载新值的成功次数。</li><li>loadExceptionCount()：返回缓存加载新值出现异常的次数。</li><li>loadExceptionRate()：返回缓存加载新值出现异常的比率。</li><li>totalLoadTime()：返回缓存加载新值所耗费的总时间。</li><li>averageLoadPenalty()：缓存加载新值耗费的平均时间，加载的总时间除以加载的次数。</li><li>evictionCount()：返回缓存中条目被移除的次数。</li><li>minus(CacheStats other)：返回一个新的表示当前CacheStats与传入CacheStats之间差异的CacheStats实例。</li><li>plus(CacheStats other)：返回一个新的表示当前CacheStats与传入CacheStats之间总计的CacheStats实例。</li></ul><h2 id="项目源码" tabindex="-1"><a class="header-anchor" href="#项目源码"><span>项目源码</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://github.com/aalansehaiyang/spring-boot-bulking  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>模块：spring-boot-bulking-guava</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27)]))}const d=e(l,[["render",p]]),u=JSON.parse('{"path":"/posts/interview/spring/springboot/Guava.html","title":"Spring Boot 集成 Guava","lang":"zh-CN","frontmatter":{"title":"Spring Boot 集成 Guava","description":"Spring Boot 集成 Guava 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/spring/springboot/Guava.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Spring Boot 集成 Guava"}],["meta",{"property":"og:description","content":"Spring Boot 集成 Guava 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring Boot 集成 Guava\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":4.17,"words":1252},"filePathRelative":"posts/interview/spring/springboot/Guava.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p>","autoDesc":true}');export{d as comp,u as data};
