import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as o,o as t}from"./app-NomDibRt.js";const a="/vpress/images/middleware/mq/31-1.jpg",l="/vpress/images/middleware/mq/31-3.jpg",r="/vpress/images/middleware/mq/31-2-2.jpg",n="/vpress/images/middleware/mq/31-4.jpg",p="/vpress/images/middleware/mq/31-5.jpg",c="/vpress/images/middleware/mq/31-6.jpg",d="/vpress/images/middleware/mq/31-7.jpg",u="/vpress/images/middleware/mq/31-8.jpg",m={};function g(h,e){return t(),i("div",null,e[0]||(e[0]=[o('<h1 id="如何保证-mq消息是有序的" tabindex="-1"><a class="header-anchor" href="#如何保证-mq消息是有序的"><span>如何保证 MQ消息是有序的？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>为了系统间解耦，我们通常会引入<code>MQ</code> 框架，大家各司其职共同完成上下游的业务流程。</p><div align="left"><img src="'+a+'" width="650px"></div><h2 id="大致过程" tabindex="-1"><a class="header-anchor" href="#大致过程"><span>大致过程</span></a></h2><ul><li>生产端，创建一条消息，通过网络发送到 MQ Server</li><li>MQ 将 消息存储在topic 的<strong>一个分区</strong>里</li><li>消费端，从分区中拉取消息，消费处理</li></ul><p><strong>但现实往往不一样！MQ 架构设计要满足高并发、高性能、高可用等指标</strong></p><div align="left"><img src="'+l+'" width="260px"></div><p>单分区，达不到我们的吞吐量要求，我们考虑采用<code>多分区</code>架构设计，正所谓 ”三个臭皮匠赛过一个诸葛亮“，多分区可以有效分摊全局压力，提升整体系统性能。</p><div align="left"><img src="'+r+'" width="650px"></div><p>两台 MQ机器，组成一个集群，原先一个分区存储<code>6条消息</code>，现在分摊到两个分区，每个分区各存储<code>3条消息</code>，性能比上面那个提升一倍。</p><p>貌似可以满足我们的需求，但任何事情都有两面性！</p><h2 id="我们看看下面业务场景" tabindex="-1"><a class="header-anchor" href="#我们看看下面业务场景"><span>我们看看下面业务场景</span></a></h2><p>一个用户在电商网站上下订单到交易完成，中间会经历一系列动作，订单的状态也会随之变化，一个订单会产生多条MQ消息，<code>下单</code>、<code>付款</code>、<code>发货</code>、<code>买家确认收货</code>，消费端需要严格按照业务状态机的顺序处理，否则，就会出现业务问题。</p><p>我们发现，消息带上了状态，不再是一个个独立的个体，有了上下文依赖关系！</p><p>对于这个问题，突然想到<code>HTTP协议</code>，其本身也是无状态的，也就是说前后两次请求没有关联，但有些业务功能有登录要求，那怎么解决？</p><blockquote><p>引入Cookie机制，每次请求客户端额外传输一些数据，来达到上下文关联。</p></blockquote><p><strong>回到MQ的消息顺序问题，我们要如何解决？</strong></p><div align="left"><img src="'+n+`" width="650px"></div><p>答案：各退一步，保证局部有序。</p><blockquote><p>比如上面的电商例子，只要保证一个订单的多条状态消息在同一个分区，便可以满足业务需求，这个方案可以覆盖大部分的业务场景。</p></blockquote><p>这里面只需要有一个<code>路由策略</code>组件，由它决定消息该放到哪个分区中！</p><p>考虑到市面MQ开源框架很多，常见的如：Kafka、Pulsar、RabbitMQ、RocketMQ 等，API方法略有区别，但设计思路是相通的。接下来，我们以 <code>RocketMQ</code> 为例：</p><p><strong>生产端提供了一个接口 <code>MessageQueueSelector</code></strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public interface MessageQueueSelector {</span></span>
<span class="line"><span>   MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接口内定义一个select方法，具体参数含义：</p><ul><li>mqs：该Topic下所有的队列分片</li><li>msg：待发送的消息</li><li>arg：发送消息时传递的参数</li></ul><p>关于<code>MessageQueueSelector</code>接口，RocketMQ 框架提供了三个默认实现类：</p><ul><li>1、SelectMessageQueueByHash：</li></ul><blockquote><p>arg参数的<code>hashcode</code>的绝对值，然后对mqs.size()取余，得到目标队列在mqs的下标</p></blockquote><ul><li>2、SelectMessageQueueByRandom：</li></ul><blockquote><p>对<code>mqs.size()</code>值取随机数作为目标队列在mqs的下标</p></blockquote><ul><li>3、SelectMessageQueueByMachineRoom</li></ul><blockquote><p>返回null</p></blockquote><p><strong>特别注意：</strong></p><p>虽然保证了单个分片的消息有序，但每个分片的消费者只能是单线程处理，因为多线程无法控制消费顺序。这个可能会损失一些性能。</p><p><strong>这里又引出另一个问题，如何保证一个队列只能有一个消费端呢？</strong></p><p>1、org.apache.rocketmq.client.impl.consumer.RebalanceImpl#updateProcessQueueTableInRebalance</p><div align="left"><img src="`+p+`" width="650px"></div><ul><li>遍历一个topic下所有的<code>MessageQueue</code></li><li><code>isOrder &amp;&amp; !this.lock(mq)</code> 尝试对它加锁，确保一个<code>MessageQueue</code>只能被一个消费者处理</li></ul><p>2、将<code>PullRequest</code>对象放入<code>PullMessageService</code>的<code>pullRequestQueue</code>队列中</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public void dispatchPullRequest(List&lt;PullRequest&gt; pullRequestList) {</span></span>
<span class="line"><span>    for (PullRequest pullRequest : pullRequestList) {</span></span>
<span class="line"><span>        this.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span></span>
<span class="line"><span>        log.info(&quot;doRebalance, {}, add a new pull request {}&quot;, consumerGroup, pullRequest);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3、org.apache.rocketmq.client.impl.consumer.PullMessageService#run</p><div align="left"><img src="`+c+'" width="650px"></div><ul><li><code>PullMessageService</code> 是一个<code>Runnable</code>线程任务</li><li>无限循环，从队列中拉取、处理消息</li></ul><p><strong>另一个问题，如何保证一个队列，只有一个线程在处理消息呢？</strong></p><p>1、org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl#pullMessage</p><div align="left"><img src="'+d+'" width="650px"></div><ul><li><code>ConsumeMessageService</code> 中有两个实现类，因为我们有消费顺序要求，会选择<code>ConsumeMessageOrderlyService</code>来处理业务</li></ul><p>2、 ConsumeMessageOrderlyService.ConsumeRequest</p><div align="left"><img src="'+u+'" width="650px"></div><ul><li>从<code>ConcurrentMap</code>中获取<code>messageQueue</code>对应的锁对象</li><li>通过 <code>synchronized</code> 关键字，线程来抢占锁，互斥关系，从而保证了一个<code>MessageQueue</code>只能有一个线程并发处理</li></ul><p><strong>继续往下看，如果扩容了怎么办？</strong></p><p>原来有6个分区，<code>order_id_1</code>的消息在<code>MessageQueue6</code> 中，此时扩容一倍，现在12个分区，<code>order_id_1</code>订单后面产生的消息可能路由到了<code>MessageQueue8</code> 中，同一个订单的消息分布在两个分区中，无法保证顺序。</p><p>我们能做的是，先将存量消息处理完，再扩容。如果是在线业务，可以搞个临时topic，先将消息暂时堆积，待扩容后，按新的路由规则重新发送。</p><p><strong>顺序消息，如果某条失败了怎么办？会不会一直阻塞？</strong></p><p>1、如果失败，不会提交消费位移，系统会自动重试（有重试上限），此时会阻塞后面的消息消费，直到这条消息处理完</p><p>2、如果这个消息达到重试上限，依然失败，会进入<code>死信队列</code>，可以继续处理后面的消息</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1144#/detail/pc?id=8482" target="_blank" rel="noopener noreferrer">高并发下 MQ 如何保证顺序消费？</a></li><li><a href="https://cloud.tencent.com/developer/article/1534591" target="_blank" rel="noopener noreferrer">聊聊rocketmq的MessageQueueSelector</a></li><li><a href="https://blog.csdn.net/weixin_34452850/article/details/82664799" target="_blank" rel="noopener noreferrer">RocketMQ详解(7)——顺序消费</a></li></ul>',61)]))}const M=s(m,[["render",g]]),q=JSON.parse('{"path":"/posts/interview/middleware/mq/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20MQ%E6%B6%88%E6%81%AF%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%9F.html","title":"如何保证 MQ消息是有序的？","lang":"zh-CN","frontmatter":{"title":"如何保证 MQ消息是有序的？","description":"如何保证 MQ消息是有序的？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 为了系统间解耦，我们通常会引入MQ 框架，大家各司其职共同完成上下游的业务流程。 大致过程 生产端，创建一条消息，通过网络发送到 MQ Server MQ 将 消息存储在topic 的一个分区里 消费端，从分区...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mq/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%20MQ%E6%B6%88%E6%81%AF%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"如何保证 MQ消息是有序的？"}],["meta",{"property":"og:description","content":"如何保证 MQ消息是有序的？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 为了系统间解耦，我们通常会引入MQ 框架，大家各司其职共同完成上下游的业务流程。 大致过程 生产端，创建一条消息，通过网络发送到 MQ Server MQ 将 消息存储在topic 的一个分区里 消费端，从分区..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何保证 MQ消息是有序的？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":4.89,"words":1467},"filePathRelative":"posts/interview/middleware/mq/如何保证 MQ消息是有序的？.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>为了系统间解耦，我们通常会引入<code>MQ</code> 框架，大家各司其职共同完成上下游的业务流程。</p>\\n<div align=\\"left\\">\\n    <img src=\\"/images/middleware/mq/31-1.jpg\\" width=\\"650px\\">\\n</div>","autoDesc":true}');export{M as comp,q as data};
