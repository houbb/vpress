import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as a}from"./app-NomDibRt.js";const l="/vpress/images/middleware/mysql/2-9.jpg",p="/vpress/images/middleware/mysql/2-1.jpg",t="/vpress/images/middleware/mysql/2-3.jpg",r="/vpress/images/middleware/mysql/2-4.jpg",d="/vpress/images/middleware/mysql/2-5.jpg",o="/vpress/images/middleware/mysql/2-6.jpg",c="/vpress/images/middleware/mysql/2-7.jpg",h="/vpress/images/middleware/mysql/2-8.jpg",m={};function b(v,s){return a(),i("div",null,s[0]||(s[0]=[n('<h1 id="跑了4个实验-实战讲解-mysql的行锁、间隙锁-​" tabindex="-1"><a class="header-anchor" href="#跑了4个实验-实战讲解-mysql的行锁、间隙锁-​"><span>跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>今天跟大家聊一聊MySQL的事务隔离，并通过一些实验做了些总结。光说不练，假把式，没有经过实践就没有话语权。</p><div align="left"><img src="'+l+'" width="500px"></div><p>我们都知道数据库有四种隔离级别，分别是：</p><ul><li>读未提交（READ UNCOMMITTED）</li><li>读已提交 （READ COMMITTED）</li><li>可重复读 （REPEATABLE READ）</li><li>串行化 （SERIALIZABLE）</li></ul><div align="left"><img src="'+p+`" width="500px"></div><h2 id="实验前的准备工作" tabindex="-1"><a class="header-anchor" href="#实验前的准备工作"><span>实验前的准备工作</span></a></h2><p><strong>1、基础环境</strong></p><ul><li>当前的数据库版本</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; select version();</span></span>
<span class="line"><span>+-----------+</span></span>
<span class="line"><span>| version() |</span></span>
<span class="line"><span>+-----------+</span></span>
<span class="line"><span>| 8.0.27    |</span></span>
<span class="line"><span>+-----------+</span></span>
<span class="line"><span>1 row in set (0.00 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>当前的事务隔离级别</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show variables like &#39;transaction_isolation&#39;;</span></span>
<span class="line"><span>+-----------------------+-----------------+</span></span>
<span class="line"><span>| Variable_name         | Value           |</span></span>
<span class="line"><span>+-----------------------+-----------------+</span></span>
<span class="line"><span>| transaction_isolation | REPEATABLE-READ |</span></span>
<span class="line"><span>+-----------------------+-----------------+</span></span>
<span class="line"><span>1 row in set (0.00 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、创建个人收支表，并对 <code>income</code> 字段创建索引，<code>expend</code>字段没有索引</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE \`person\` (</span></span>
<span class="line"><span>  \`id\` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span></span>
<span class="line"><span>  \`income\` bigint(20) NOT NULL COMMENT &#39;收入&#39;,</span></span>
<span class="line"><span>  \`expend\` bigint(20) NOT NULL COMMENT &#39;支出&#39;,</span></span>
<span class="line"><span>  PRIMARY KEY (\`id\`),</span></span>
<span class="line"><span>  KEY \`idx_income\` (\`income\`)</span></span>
<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#39;个人收支表&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3、初始化表数据，插入5条记录</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>insert into person values(100,1000,1000);</span></span>
<span class="line"><span>insert into person values(200,2000,2000);</span></span>
<span class="line"><span>insert into person values(300,3000,3000);</span></span>
<span class="line"><span>insert into person values(400,4000,4000);</span></span>
<span class="line"><span>insert into person values(500,5000,5000);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实验一-事务a、b的条件字段没有索引" tabindex="-1"><a class="header-anchor" href="#实验一-事务a、b的条件字段没有索引"><span>实验一：（事务A、B的条件字段没有索引）</span></a></h3><div align="left"><img src="`+t+`" width="500px"></div><p><strong>实验过程：</strong></p><p>为了便于描述，我们定义时间轴坐标，用T1、T2、T3... 表示当前时刻。</p><p>T1：</p><p>事务A开启事务，并执行 select * from person where expend=4000 for update;</p><p>由于 <code>expend</code> 字段没有索引，需要扫描全表。此时加的锁是所有记录的行锁和它们之间的间隙锁，也称为 next-key lock，前开后闭区间。分别是 (-∞,100]、(100,200]、(200,300]、(300,400]、(400，500]、(500, +supremum]</p><p>T2：</p><p>事务B开启事务，执行插入语句 insert into person values(401,4001,4001); <code>此时一直被阻塞住，因为并没有获得锁</code>。</p><p>面的这种情况，有两种选择：一种等到事务A结束（提交或回滚）；另一种等事务锁超时。</p><p><strong>接着这个话题，我们稍微扩展介绍下锁超时：</strong></p><p>MySQL数据库采用InnoDB模式，默认参数：<code>innodb_lock_wait_timeout </code>设置锁等待的时间是50s，一旦数据库锁超过这个时间就会报错。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当然，我们也可以通过命令来查看、修改这个超时时间</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 查看超时时间</span></span>
<span class="line"><span>SHOW GLOBAL VARIABLES LIKE &#39;innodb_lock_wait_timeout&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 修改时间</span></span>
<span class="line"><span>SET GLOBAL innodb_lock_wait_timeout=120;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>T3：</p><p>事务A ，执行 commit 操作， 提交事务</p><p>T4：</p><p>事务B，插入一条记录，insert into person values(401,4001,4001); 操作成功。</p><p>此时 select * from person; 可以看到新插入的记录</p><h3 id="实验二-事务a、b的条件字段有创建索引" tabindex="-1"><a class="header-anchor" href="#实验二-事务a、b的条件字段有创建索引"><span>实验二：（事务A、B的条件字段有创建索引）</span></a></h3><div align="left"><img src="`+r+'" width="650px"></div><div align="left"><img src="'+d+'" width="650px"></div><p>T1：</p><p>事务A，开启事务，并执行 select * from person where income=3000 for update，命中记录且 income 有索引，此时的加锁区间是 income=3000 的行记录以及与下一个值4000之间的空隙（行锁+间隙锁），也就是[3000，4000]</p><p>T2：</p><p>事务B，开始事务，执行 insert into person values(301,3001,3001); 没有抢到锁，线程被阻塞住，直到事务A提交事务并释放锁。</p><h3 id="实验三-自动识别死锁" tabindex="-1"><a class="header-anchor" href="#实验三-自动识别死锁"><span>实验三：（自动识别死锁）</span></a></h3><div align="left"><img src="'+o+'" width="650px"></div><div align="left"><img src="'+c+'" width="650px"></div><p>特别说明：</p><p>T3：事务A执行insert操作，被事务B的锁拦截住了</p><p>T4：同理，事务B执行insert操作，被事务A拦截了，这里被系统自动检测到，抛出 ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction<br> 。将事务B持有的锁释放掉，并重启事务。</p><p>T5：事务A在T3时刻的insert可以继续操作</p><h3 id="实验四-更新记录锁保护" tabindex="-1"><a class="header-anchor" href="#实验四-更新记录锁保护"><span>实验四：（更新记录锁保护）</span></a></h3><div align="left"><img src="'+h+`" width="500px"></div><p>1、事务A在执行后 update person set income=111 where income=3000; 开启了锁保护</p><p>2、这时，事务B再执行 insert into person values(307,3000,3000) 或者 update person set income=3000 where id=100，都会重新去抢夺锁，从而保证安全。</p><h2 id="知识小结" tabindex="-1"><a class="header-anchor" href="#知识小结"><span>知识小结</span></a></h2><p>1、对于事务，binlog 日志是在 <code>commit</code> 提交时才生成的</p><p>2、行锁与间隙锁有很大区别。</p><ul><li>行锁：如果事务A对 <code>id=1</code> 添加行锁，事务B则无法对 <code>id=1</code> 添加行锁</li><li>间隙锁：如果 <code>select .. from 表名 where d=6 for updata</code>，事务A 和 事务 B 都可以对（5，12）添加间隙锁。间隙锁是开区间。</li></ul><p>3、行锁和间隙锁合称 next-key lock，每个 next-key lock 是前开后闭区间。</p><p>4、<strong>只有在可重复读的隔离级别下，才会有间隙锁</strong></p><p>5、读提交级别没有间隙锁，只有行锁，但是如何保证一个间隙操作产生的 binlog 对主从数据同步产生的影响呢？我们需要把 binlog 的格式设置为 row。</p><p>其本质就是将模糊操作改成了针对具体的主键id行操作</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span># 初始语句</span></span>
<span class="line"><span>delete from order where c = 10</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 转换后语句</span></span>
<span class="line"><span>delete from order where id = 10</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>6、大部分公司的数据库的隔离级别都是<strong>读提交隔离级别加 binlog_format=row 的组合</strong></p><p>7、 大多数数据库的默认级别就是读提交（Read committed），比如Sql Server 、 Oracle。MySQL的默认级别是 可重复读（Repeatable Read ）</p>`,66)]))}const k=e(m,[["render",b]]),A=JSON.parse('{"path":"/posts/interview/middleware/mysql/%E8%B7%91%E4%BA%864%E4%B8%AA%E5%AE%9E%E9%AA%8C%EF%BC%8C%E5%AE%9E%E6%88%98%E8%AE%B2%E8%A7%A3%20MySQL%E7%9A%84%E8%A1%8C%E9%94%81%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81.html","title":"跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​","lang":"zh-CN","frontmatter":{"title":"跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​","description":"跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 今天跟大家聊一聊MySQL的事务隔离，并通过一些实验做了些总结。光说不练，假把式，没有经过实践就没有话语权。 我们都知道数据库有四种隔离级别，分别是： 读未提交（READ UNCOMMIT...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mysql/%E8%B7%91%E4%BA%864%E4%B8%AA%E5%AE%9E%E9%AA%8C%EF%BC%8C%E5%AE%9E%E6%88%98%E8%AE%B2%E8%A7%A3%20MySQL%E7%9A%84%E8%A1%8C%E9%94%81%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​"}],["meta",{"property":"og:description","content":"跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 今天跟大家聊一聊MySQL的事务隔离，并通过一些实验做了些总结。光说不练，假把式，没有经过实践就没有话语权。 我们都知道数据库有四种隔离级别，分别是： 读未提交（READ UNCOMMIT..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"跑了4个实验，实战讲解 MySQL的行锁、间隙锁...​\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":4.61,"words":1382},"filePathRelative":"posts/interview/middleware/mysql/跑了4个实验，实战讲解 MySQL的行锁、间隙锁.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>今天跟大家聊一聊MySQL的事务隔离，并通过一些实验做了些总结。光说不练，假把式，没有经过实践就没有话语权。</p>\\n<div align=\\"left\\">\\n    <img src=\\"/images/middleware/mysql/2-9.jpg\\" width=\\"500px\\">\\n</div>","autoDesc":true}');export{k as comp,A as data};
