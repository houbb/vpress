import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o as a}from"./app-NomDibRt.js";const p="/vpress/images/middleware/redis/28-8.jpg",l="/vpress/images/middleware/redis/28-1.jpg",t="/vpress/images/middleware/redis/28-2.jpg",r="/vpress/images/middleware/redis/28-3.jpg",d="/vpress/images/middleware/redis/28-5.jpg",o="/vpress/images/middleware/redis/28-6.jpg",c="/vpress/images/middleware/redis/28-7.jpg",h="/vpress/images/middleware/redis/28-4.jpg",b={};function m(u,s){return a(),n("div",null,s[0]||(s[0]=[i('<h1 id="什么是布隆过滤器-如何解决高并发缓存穿透问题" tabindex="-1"><a class="header-anchor" href="#什么是布隆过滤器-如何解决高并发缓存穿透问题"><span>什么是布隆过滤器？如何解决高并发缓存穿透问题？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>日常开发中，大家经常使用缓存，但是你知道大型的互联网公司面对高并发流量，要注意缓存穿透问题吗!!!<br> 本文会介绍布隆过滤器，空间换时间，以较低的内存空间、高效解决这个问题。</p><p>本篇文章的目录：</p><div align="left"><img src="'+p+'" width="360px"></div><h2 id="性能不够-缓存来凑" tabindex="-1"><a class="header-anchor" href="#性能不够-缓存来凑"><span>性能不够，缓存来凑</span></a></h2><p>现在的年轻人都喜欢网购，没事就逛逛淘宝，剁剁手，买些自己喜欢的东西，释放下工作压力。</p><div align="left"><img src="'+l+'" width="600px"></div><blockquote><p>地址： <a href="https://detail.tmall.com/item.htm?id=628993216729" target="_blank" rel="noopener noreferrer">https://detail.tmall.com/item.htm?id=628993216729</a></p></blockquote><p>上图是一个天猫 iphone12 的<code>商品详情页</code>，id表示商品的编号</p><p>我们都知道淘宝的访问量是非常高的，为了提升系统的吞吐量，做了很多性能优化，其中非常重要一点是将信息异构到缓存中。</p><p>有句话说的好：<strong>性能不够，缓存来凑。</strong></p><p>但是，使用缓存时，我们要关注一个重要问题，如果缓存没有命中怎么办？</p><div align="left"><img src="'+t+'" width="450px"></div><h2 id="缓存没有命中-怎么办" tabindex="-1"><a class="header-anchor" href="#缓存没有命中-怎么办"><span>缓存没有命中，怎么办？</span></a></h2><div align="left"><img src="'+r+'" width="450px"></div><ul><li>①我们先查询缓存，判断缓存中是否有数据</li><li>②如果有数据，直接返回</li><li>③如果缓存为空，我们需要再查一次数据库，并将数据格式异构化，然后预热到缓冲中，然后将结果返回</li></ul><p>注意：</p><p>步骤 ③ 存在风险漏洞，如果缓存中数据不存在，压力会转嫁给数据库。假如被竞争对手利用，搞无效请求流量攻击，瞬间大量请求打到数据库中，对系统性能产生很大影响，很容易把数据库打挂，这种现象称为缓存穿透。</p><h2 id="如何处理缓存穿透" tabindex="-1"><a class="header-anchor" href="#如何处理缓存穿透"><span>如何处理缓存穿透？</span></a></h2><p>我们的思路是，缓存中能不能判断这个数据库值的存在性，如果真的不存在，直接返回，也避免一次数据库查询。</p><p>由于不存在是个<code>无限边界</code>，所以，我们采用反向策略，将存在的值建立一个高效的检索。每次缓存取值时，先走一次判空检索。</p><p>简单归纳下，这个框架的要求：</p><ul><li>快速检索</li><li>内存空间要非常小</li></ul><p>经调研，我们发现<code>布隆过滤器</code>具备以上两个条件。</p><h2 id="什么是布隆过滤器" tabindex="-1"><a class="header-anchor" href="#什么是布隆过滤器"><span>什么是布隆过滤器？</span></a></h2><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><ul><li>优点：空间效率和查询时间都远远超过一般的算法。</li><li>缺点：有一定的误识别率，删除困难。</li></ul><h2 id="布隆过滤器如何构建" tabindex="-1"><a class="header-anchor" href="#布隆过滤器如何构建"><span>布隆过滤器如何构建？</span></a></h2><p>布隆过滤器本质上是一个 n 位的二进制数组，用0和1表示。</p><p>假如我们以商品为例，有三件商品，商品编码分别为，<code>id1</code>、<code>id2</code>、<code>id3</code></p><p>1、首先，对<code>id1</code>，进行三次哈希，并确定其在二进制数组中的位置。</p><div align="left"><img src="'+d+'" width="600px"></div><blockquote><p>三次哈希，对应的二进制数组下标分别是 2、5、8，将原始数据从 0 变为 1。</p></blockquote><p>2、对<code>id2</code>，进行三次哈希，并确定其在二进制数组中的位置。</p><div align="left"><img src="'+o+'" width="600px"></div><blockquote><p>三次哈希，对应的二进制数组下标分别是 2、7、98，将原始数据从 0 变为 1。</p></blockquote><p>下标 2，之前已经被操作设置成 1，则本次认为是哈希冲突，不需要改动。</p><p>Hash 规则：如果在 Hash 后，原始位它是 0 的话，将其从 0 变为 1；如果本身这一位就是 1 的话，则保持不变。</p><h2 id="布隆过滤器如何使用" tabindex="-1"><a class="header-anchor" href="#布隆过滤器如何使用"><span>布隆过滤器如何使用？</span></a></h2><div align="left"><img src="'+c+`" width="450px"></div><p>跟初始化的过程有点类似，当查询一件商品的缓存信息时，我们首先要判断这件商品是否存在。</p><ul><li>通过三个哈希函数对商品id计算哈希值</li><li>然后，在布隆数组中查找访问对应的位值，0或1</li><li>判断，三个值中，只要有一个不是1，那么我们认为数据是不存在的。</li></ul><p>注意：布隆过滤器只能精确判断数据不存在情况，对于存在我们只能说是可能，因为存在Hash冲突情况，当然这个概率非常低。</p><h2 id="如何减少布隆过滤器的误判" tabindex="-1"><a class="header-anchor" href="#如何减少布隆过滤器的误判"><span>如何减少布隆过滤器的误判？</span></a></h2><p>1、增加二进制位数组的长度。这样经过hash后数据会更加的离散化，出现冲突的概率会大大降低</p><p>2、增加Hash的次数，变相的增加数据特征，特征越多，冲突的概率越小</p><h2 id="布隆过滤器会不会很费内存" tabindex="-1"><a class="header-anchor" href="#布隆过滤器会不会很费内存"><span>布隆过滤器会不会很费内存？</span></a></h2><p>带着疑问，我们来做个实验</p><p>假设有1千万个数据，我们需要记录其是否存在。存在的话标记1，不存在标记为0。技术选型，框架采用Redis的<code>BitMap</code>存储。</p><p>数据初始化预热代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>redisTemplate.executePipelined(new RedisCallback&lt;Long&gt;() {</span></span>
<span class="line"><span>    @Nullable</span></span>
<span class="line"><span>    @Override</span></span>
<span class="line"><span>    public Long doInRedis(RedisConnection connection) throws DataAccessException {</span></span>
<span class="line"><span>        connection.openPipeline();</span></span>
<span class="line"><span>        for (int offset = 10000000; offset &gt;= 0; offset--) {</span></span>
<span class="line"><span>            boolean value = offset % 2 == 0 ? true : false;</span></span>
<span class="line"><span>            connection.setBit(&quot;bloom-filter-data-1&quot;.getBytes(), offset, value);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        connection.closePipeline();</span></span>
<span class="line"><span>        return null;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span>System.out.println(&quot;数据预热完成&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>性能有点慢，我们也可以采用分组形式，10000个数一组，多批次提交。</p></blockquote><div align="left"><img src="`+h+`" width="600px"></div><p>数据上传完了后，大小 1.19M，跟我们设想的一样。</p><p>计算公式： 10000000/8/1024/1024=1.19M</p><h2 id="java应用中-如何使用布隆过滤器-代码实例" tabindex="-1"><a class="header-anchor" href="#java应用中-如何使用布隆过滤器-代码实例"><span>Java应用中，如何使用布隆过滤器？代码实例</span></a></h2><p>Java语言的生态非常繁荣，提供了很多开箱即用的开源框架供我们使用。布隆过滤器也不例外，Java 中提供了一个 <code>Redisson</code> 的组件，它内置了布隆过滤器。</p><p>首先引入依赖包</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;3.11.1&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>/**</span></span>
<span class="line"><span> * @author 微信公众号：老马啸西风</span></span>
<span class="line"><span> */</span></span>
<span class="line"><span>@Test</span></span>
<span class="line"><span>public void test5() {</span></span>
<span class="line"><span>    Config config = new Config();</span></span>
<span class="line"><span>    config.useSingleServer().setAddress(&quot;redis://172.16.67.37:6379&quot;);</span></span>
<span class="line"><span>    RedissonClient cient = Redisson.create(config);</span></span>
<span class="line"><span>    RBloomFilter&lt;String&gt; bloomFilter = cient.getBloomFilter(&quot;test5-bloom-filter&quot;);</span></span>
<span class="line"><span>    // 初始化布隆过滤器，数组长度100W，误判率 1%</span></span>
<span class="line"><span>    bloomFilter.tryInit(1000000L, 0.01);</span></span>
<span class="line"><span>    // 添加数据</span></span>
<span class="line"><span>    bloomFilter.add(&quot;老马&quot;);</span></span>
<span class="line"><span>    // 判断是否存在</span></span>
<span class="line"><span>    System.out.println(bloomFilter.contains(&quot;老马啸西风&quot;));</span></span>
<span class="line"><span>    System.out.println(bloomFilter.contains(&quot;老马&quot;));</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>false   // 肯定不存在</span></span>
<span class="line"><span>true    // 可能存在，有1%的误判率</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：误判率设置过小，会产生更多次的 Hash 操作，降低系统的性能。通常我们的建议值是 1%</p><h2 id="布隆过滤器二进制数组-如何处理删除" tabindex="-1"><a class="header-anchor" href="#布隆过滤器二进制数组-如何处理删除"><span>布隆过滤器二进制数组，如何处理删除？</span></a></h2><p>初始化后的布隆过滤器，可以直接拿来使用了。但是如果原始数据删除了怎么办？布隆过滤器二进制数组如何维护？</p><p>直接删除不行吗？</p><p>还真不行！因为这里面有Hash冲突的可能，会导致误删。</p><p>怎么办？</p><p>1、开发定时任务，每隔几个小时，自动创建一个新的布隆过滤器数组，替换老的，有点<code>CopyOnWriteArrayList</code>的味道</p><p>2、布隆过滤器增加一个等长的数组，存储计数器，主要解决冲突问题，每次删除时对应的计数器减一，如果结果为0，更新主数组的二进制值为0</p><h2 id="布隆过滤器的应用场景" tabindex="-1"><a class="header-anchor" href="#布隆过滤器的应用场景"><span>布隆过滤器的应用场景</span></a></h2><ul><li>本文重点介绍的，解决缓存穿透</li><li>网页爬虫对URL的去重，避免爬取相同的URL地址</li><li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱</li></ul>`,75)]))}const f=e(b,[["render",m]]),k=JSON.parse('{"path":"/posts/interview/middleware/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%EF%BC%9F.html","title":"什么是布隆过滤器？如何解决高并发缓存穿透问题？","lang":"zh-CN","frontmatter":{"title":"什么是布隆过滤器？如何解决高并发缓存穿透问题？","description":"什么是布隆过滤器？如何解决高并发缓存穿透问题？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 日常开发中，大家经常使用缓存，但是你知道大型的互联网公司面对高并发流量，要注意缓存穿透问题吗!!! 本文会介绍布隆过滤器，空间换时间，以较低的内存空间、高效解决这个问题。 本篇文章的目录： 性...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/redis/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"什么是布隆过滤器？如何解决高并发缓存穿透问题？"}],["meta",{"property":"og:description","content":"什么是布隆过滤器？如何解决高并发缓存穿透问题？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 日常开发中，大家经常使用缓存，但是你知道大型的互联网公司面对高并发流量，要注意缓存穿透问题吗!!! 本文会介绍布隆过滤器，空间换时间，以较低的内存空间、高效解决这个问题。 本篇文章的目录： 性..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"什么是布隆过滤器？如何解决高并发缓存穿透问题？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":6.58,"words":1973},"filePathRelative":"posts/interview/middleware/redis/什么是布隆过滤器？如何解决高并发缓存穿透问题？.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>日常开发中，大家经常使用缓存，但是你知道大型的互联网公司面对高并发流量，要注意缓存穿透问题吗!!!<br>\\n本文会介绍布隆过滤器，空间换时间，以较低的内存空间、高效解决这个问题。</p>","autoDesc":true}');export{f as comp,k as data};
