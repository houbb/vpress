import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as i}from"./app-NomDibRt.js";const l="/vpress/images/spring/springboot/7-2.jpg",p="/vpress/images/spring/springboot/7-1.jpg",t="/vpress/images/spring/springboot/7-3.jpg",r={};function d(c,s){return i(),n("div",null,s[0]||(s[0]=[a('<h1 id="高性能本地缓存组件-caffeine-cache" tabindex="-1"><a class="header-anchor" href="#高性能本地缓存组件-caffeine-cache"><span>高性能本地缓存组件 Caffeine Cache</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p><p>Redis 作为分布式缓存组件提供多个服务间的缓存，但是 <strong>Redis 有网络开销，增加链路耗时</strong>。本地缓存是直接从本地内存中读取数据，没有网络开销，性能更高，例如秒杀系统或者数据量小的缓存等，比远程缓存更合适。</p><h2 id="caffeine-介绍" tabindex="-1"><a class="header-anchor" href="#caffeine-介绍"><span>Caffeine 介绍</span></a></h2><p>Caffeine 是基于 JAVA 8 的高性能缓存库。参考 Google Guava 的API对缓存框架重写，基于LRU算法实现，支持多种缓存过期策略。</p><p>Spring Boot 1.x版本中的默认本地缓存是Guava Cache。在 Spring5 (spring boot 2.x) 后，Spring 官方放弃了 Guava Cache 作为缓存机制，而是使用性能更优秀的 Caffeine 作为默认缓存组件，这对于Caffeine来说是一个很大的肯定。</p><p>为什么Spring会这样做呢？其实在Caffeine的Benchmarks里给出了非常靓的数据，针对读和写场景，与其他几个缓存框架进行了比较，Caffeine的性能表现非常突出。</p><div align="left"><img src="'+l+`" width="800px"></div><h2 id="项目集成" tabindex="-1"><a class="header-anchor" href="#项目集成"><span>项目集成</span></a></h2><p>在 pom.xml 中添加 caffeine jar 包依赖：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;2.8.6&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化本地缓存类的Bean实例，并设置一系列配置参数，满足个性化业务场景需求。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public static LoadingCache&lt;Long, User&gt; loadingCache = Caffeine.newBuilder()</span></span>
<span class="line"><span>    // 初始的缓存空间大小</span></span>
<span class="line"><span>    .initialCapacity(5)</span></span>
<span class="line"><span>    // 缓存的最大条数</span></span>
<span class="line"><span>    .maximumSize(10)</span></span>
<span class="line"><span>    .expireAfterWrite(4, TimeUnit.SECONDS)</span></span>
<span class="line"><span>    .expireAfterAccess(10, TimeUnit.SECONDS)</span></span>
<span class="line"><span>    .refreshAfterWrite(6, TimeUnit.SECONDS)</span></span>
<span class="line"><span>    .recordStats()</span></span>
<span class="line"><span>    //设置缓存的移除通知</span></span>
<span class="line"><span>    .removalListener(new RemovalListener&lt;Long, User&gt;() {</span></span>
<span class="line"><span>        @Override</span></span>
<span class="line"><span>        public void onRemoval(@Nullable Long key, @Nullable User user, @NonNull RemovalCause removalCause) {</span></span>
<span class="line"><span>            System.out.printf(&quot;Key： %s ，值：%s was removed!原因 (%s) \\n&quot;, key, user, removalCause);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    .build(id -&gt; {</span></span>
<span class="line"><span>        System.out.println(&quot;缓存未命中，从数据库加载，用户id：&quot; + id);</span></span>
<span class="line"><span>        return User.builder().id(id).userName(&quot;Lily&quot;).age(new Random().nextInt(20)).build();</span></span>
<span class="line"><span>    });</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>参数说明：</strong></p><ul><li>initialCapacity 初始的缓存空间大小</li><li>maximumSize 缓存的最大条数</li><li>maximumWeight 缓存的最大权重</li><li>expireAfterAccess 最后一次写入或访问后，经过固定时间过期</li><li>expireAfterWrite 最后一次写入后，经过固定时间过期</li><li>refreshAfterWrite 写入后，经过固定时间过期，下次访问返回旧值并触发刷新</li><li>weakKeys 打开 key 的弱引用</li><li>weakValues 打开 value 的弱引用</li><li>softValues 打开 value 的软引用</li><li>recordStats 缓存使用统计</li></ul><blockquote><p>expireAfterWrite 和 expireAfterAccess 同时存在时，以 expireAfterWrite 为准。<br><br> weakValues 和 softValues 不可以同时使用。<br><br> maximumSize 和 maximumWeight 不可以同时使用。</p></blockquote><p><strong>构造LoadingCache对象，里面提供了很多方法来操作缓存，比如 <code>getIfPresent</code> 、<code>put</code>、<code>invalidate</code>等，详细可以参考下图：</strong></p><div align="left"><img src="`+p+`" width="800px"></div><p>关于Caffine Cache 的各种参数设置，以及常用的API在各种场景下如何使用演示测试</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RunWith(SpringRunner.class)</span></span>
<span class="line"><span>@SpringBootTest(classes = StartApplication.class)</span></span>
<span class="line"><span>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</span></span>
<span class="line"><span>public class CacheServiceTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * .refreshAfterWrite(6,TimeUnit.SECONDS)</span></span>
<span class="line"><span>     * .build(id -&gt; {</span></span>
<span class="line"><span>     *      Thread.sleep(2_000);</span></span>
<span class="line"><span>     *      System.out.println(&quot;缓存未命中，从数据库加载，用户id：&quot; + id);</span></span>
<span class="line"><span>     *      return User.builder().id(id).userName(&quot;Lily&quot;).age(new Random().nextInt(20)).build();</span></span>
<span class="line"><span>     * });</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test1_refreshAfterWrite() throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span>        User user1 = LocalCacheService.loadingCache.get(1L);</span></span>
<span class="line"><span>        System.out.println(&quot;第1次查user1：&quot; + user1);</span></span>
<span class="line"><span>        Thread.sleep(10_000);</span></span>
<span class="line"><span>        // 缓存不存在，返回旧值，并触发缓存刷新</span></span>
<span class="line"><span>        user1 = LocalCacheService.loadingCache.get(1L);</span></span>
<span class="line"><span>        System.out.println(&quot;第2次查user1：&quot; + user1);</span></span>
<span class="line"><span>        Thread.sleep(5_000);</span></span>
<span class="line"><span>        user1 = LocalCacheService.loadingCache.get(1L);</span></span>
<span class="line"><span>        System.out.println(&quot;第3次查user1：&quot; + user1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * .expireAfterWrite(4, TimeUnit.SECONDS)</span></span>
<span class="line"><span>     * .expireAfterAccess(10,TimeUnit.SECONDS)</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test2() throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span>        User user1 = LocalCacheService.loadingCache.get(1L);</span></span>
<span class="line"><span>        System.out.println(&quot;第1次查user1：&quot; + user1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        Thread.sleep(6_000);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        user1 = LocalCacheService.loadingCache.get(1L);</span></span>
<span class="line"><span>        System.out.println(&quot;第2次查user1：&quot; + user1);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /**</span></span>
<span class="line"><span>     * 容量上限是10，超过容量会LRU置换</span></span>
<span class="line"><span>     * maximumSize(10)</span></span>
<span class="line"><span>     */</span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test3() throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span>        for (int i = 1; i &lt; 16; i++) {</span></span>
<span class="line"><span>            User user1 = LocalCacheService.loadingCache.get(Long.valueOf(i));</span></span>
<span class="line"><span>            System.out.println(String.format(&quot;第%s次查user：%s&quot;, i, user1));</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Thread.sleep(30_000);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="缓存填充策略" tabindex="-1"><a class="header-anchor" href="#缓存填充策略"><span>缓存填充策略</span></a></h2><p>缓存的填充方式有三种，手动、同步和异步</p><h3 id="手动加载" tabindex="-1"><a class="header-anchor" href="#手动加载"><span>手动加载</span></a></h3><p>手动将值放入缓存后再检索</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>cache.put(key, dataObject);</span></span>
<span class="line"><span>dataObject = cache.getIfPresent(key);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以通过 <code>cache.getIfPresent(key)</code> 方法来获取一个key的值，通过cache.put(key, value)方法显示的将数值放入缓存，但是这样会覆盖缓原来key的数据。</p><p>建议使用cache.get(key，k - &gt; value) 的方式，get 方法将一个参数为 key 的 Function (createExpensiveGraph) 作为参数传入。如果缓存中不存在该键，则调用这个 Function 函数，并将返回值作为该缓存的值插入缓存中。get 方法是以阻塞方式执行，即使多个线程同时请求该值也只会调用一次Function方法。这样可以避免与其他线程的写入竞争，这也是为什么使用 get 优于 getIfPresent 的原因。</p><h3 id="同步加载" tabindex="-1"><a class="header-anchor" href="#同步加载"><span>同步加载</span></a></h3><p>这种加载缓存方式使用了与用于初始化值的 Function 的手动策略类似的 get 方法。让我们看看如何使用它。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Caffeine.newBuilder()</span></span>
<span class="line"><span>.maximumSize(10)</span></span>
<span class="line"><span>.build(id -&gt; {</span></span>
<span class="line"><span>    System.out.println(&quot;缓存未命中，从数据库加载，用户id：&quot; + id);</span></span>
<span class="line"><span>    return User.builder().id(id).userName(&quot;Lily&quot;).age(new Random().nextInt(20)).build();</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="异步加载" tabindex="-1"><a class="header-anchor" href="#异步加载"><span>异步加载</span></a></h3><p>此策略与同步加载相似，但是以异步方式执行操作，并返回一个包含值的 <code>CompletableFuture</code></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>AsyncLoadingCache&lt;String, Object&gt; asyncLoadingCache=Caffeine.newBuilder()</span></span>
<span class="line"><span>		.maximumSize(10)</span></span>
<span class="line"><span>		.buildAsync(id -&gt; {</span></span>
<span class="line"><span>		    System.out.println(&quot;缓存未命中，从数据库加载，用户id：&quot; + id);</span></span>
<span class="line"><span>		    return User.builder().id(id).userName(&quot;Lily&quot;).age(new Random().nextInt(20)).build();</span></span>
<span class="line"><span>		});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="驱逐策略-eviction" tabindex="-1"><a class="header-anchor" href="#驱逐策略-eviction"><span>驱逐策略（eviction）</span></a></h2><p>Caffeine提供三类驱逐策略：基于大小（size-based），基于时间（time-based）和基于引用（reference-based）。</p><h3 id="基于大小-size-based" tabindex="-1"><a class="header-anchor" href="#基于大小-size-based"><span>基于大小（size-based）</span></a></h3><p>基于大小驱逐，有两种方式：一种是基于缓存大小，一种是基于权重。</p><p>使用<code>Caffeine.maximumSize(long)</code>方法来指定缓存的最大容量。当缓存超出这个容量的时候，会使用<code>Window TinyLfu</code>策略来删除缓存。</p><p>也可以使用权重的策略来进行驱逐，可以使用<code>Caffeine.weigher(Weigher)</code> 函数来指定权重，使用<code>Caffeine.maximumWeight(long) </code>函数来指定缓存最大权重值。</p><blockquote><p>maximumWeight 与 maximumSize 不可以同时使用。</p></blockquote><h3 id="基于时间-time-based" tabindex="-1"><a class="header-anchor" href="#基于时间-time-based"><span>基于时间（Time-based）</span></a></h3><p>Caffeine提供了三种定时驱逐策略：</p><ul><li>expireAfterAccess(long, TimeUnit)：在最后一次访问或者写入后开始计时，在指定的时间后过期。假如一直有请求访问该key，那么这个缓存将一直不会过期。</li><li>expireAfterWrite(long, TimeUnit)： 在最后一次写入缓存后开始计时，在指定的时间后过期。</li><li>expireAfter(Expiry)： 自定义策略，过期时间由<code>Expiry</code>实现独自计算。</li></ul><h3 id="基于引用-reference-based" tabindex="-1"><a class="header-anchor" href="#基于引用-reference-based"><span>基于引用（reference-based）</span></a></h3><p>我们可以将缓存的驱逐配置成基于垃圾回收器。为此，我们可以将key 和 value 配置为弱引用或只将值配置成软引用。</p><div align="left"><img src="`+t+`" width="800px"></div><blockquote><p>注意：AsyncLoadingCache不支持弱引用和软引用。</p></blockquote><p>Caffeine.weakKeys() 使用弱引用存储key。如果没有其他地方对该key有强引用，那么该缓存就会被垃圾回收器回收。由于垃圾回收器只依赖于身份(identity)相等，因此这会导致整个缓存使用身份 (==) 相等来比较 key，而不是使用 equals()。</p><p>Caffeine.weakValues() 使用弱引用存储value。如果没有其他地方对该value有强引用，那么该缓存就会被垃圾回收器回收。由于垃圾回收器只依赖于身份(identity)相等，因此这会导致整个缓存使用身份 (==) 相等来比较 key，而不是使用 equals()。</p><p>Caffeine.softValues() 使用软引用存储value。当内存满后，软引用的对象使用最近最少使用(least-recently-used ) 的方式进行垃圾回收。由于使用软引用是需要等到内存满了才进行回收，所以我们通常建议给缓存配置一个使用内存的最大值。 softValues() 将使用身份相等(identity) (==) 而不是equals() 来比较值。</p><blockquote><p>注意：Caffeine.weakValues()和Caffeine.softValues()不可以一起使用。</p></blockquote><h2 id="手动删除缓存" tabindex="-1"><a class="header-anchor" href="#手动删除缓存"><span>手动删除缓存</span></a></h2><p>任何时候，你都可以主动使缓存失效，而不用等待缓存被驱逐</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 单个key</span></span>
<span class="line"><span>cache.invalidate(key)</span></span>
<span class="line"><span>// 批量key</span></span>
<span class="line"><span>cache.invalidateAll(keys)</span></span>
<span class="line"><span>// 所有key</span></span>
<span class="line"><span>cache.invalidateAll()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="统计" tabindex="-1"><a class="header-anchor" href="#统计"><span>统计</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Cache&lt;String, Object&gt; cache = Caffeine.newBuilder()</span></span>
<span class="line"><span>    .maximumSize(10_000)</span></span>
<span class="line"><span>    .recordStats()</span></span>
<span class="line"><span>    .build();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用<code>Caffeine.recordStats()</code>, 可以转化成一个统计的集合。 通过 <code>Cache.stats()</code> 返回一个CacheStats。CacheStats提供以下统计方法：</p><ul><li>hitRate()： 返回缓存命中率</li><li>evictionCount()： 缓存回收数量</li><li>averageLoadPenalty()： 加载新值的平均时间</li></ul><h2 id="项目源码" tabindex="-1"><a class="header-anchor" href="#项目源码"><span>项目源码</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://github.com/aalansehaiyang/spring-boot-bulking  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>模块：spring-boot-bulking-caffeine</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://www.jianshu.com/p/9a80c662dac4" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/9a80c662dac4</a></li></ul>`,63)]))}const h=e(r,[["render",d]]),v=JSON.parse('{"path":"/posts/interview/spring/springboot/Caffeine.html","title":"高性能本地缓存组件 Caffeine Cache","lang":"zh-CN","frontmatter":{"title":"高性能本地缓存组件 Caffeine Cache","description":"高性能本地缓存组件 Caffeine Cache 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/spring/springboot/Caffeine.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"高性能本地缓存组件 Caffeine Cache"}],["meta",{"property":"og:description","content":"高性能本地缓存组件 Caffeine Cache 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"高性能本地缓存组件 Caffeine Cache\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":7.2,"words":2160},"filePathRelative":"posts/interview/spring/springboot/Caffeine.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p>","autoDesc":true}');export{h as comp,v as data};
