import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-NomDibRt.js";const l="/vpress/images/arch/system/11-1.jpg",p="/vpress/images/arch/system/11-2.jpg",d="/vpress/images/arch/system/11-3.jpg",r="/vpress/images/arch/system/11-4.jpg",t="/vpress/images/arch/system/11-5.jpg",c="/vpress/images/arch/system/11-10-1.jpg",o="/vpress/images/arch/system/11-9.jpg",u="/vpress/images/arch/system/11-7.jpg",v={};function b(h,s){return i(),e("div",null,s[0]||(s[0]=[a('<h1 id="外部接口大量超时-把整个系统拖垮-引发雪崩-如何解决-熔断" tabindex="-1"><a class="header-anchor" href="#外部接口大量超时-把整个系统拖垮-引发雪崩-如何解决-熔断"><span>外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断...</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>大家好，我是老马~</p><p>互联网+ 时代，业务数字化已经蔓延到你能想到的各个行业。各种业务功能、营销玩法越来越多，系统也越来越复杂。</p><p>面对不断复杂的业务系统，脑子越来越不够用了</p><div align="left"><img src="'+l+'" width="250px"></div><p>于是 <code>聪明的人们</code> 提出了 <code>微服务</code> 的设计思想</p><p>本着 <code>复杂的事情简单化</code> 的原则，我们将一个大的系统拆分成若干个子系统，每个 <code>子系统</code> 职责单一，按 DDD 的设计理念，承载一个子域的业务建设。</p><p>于是，人们可以将精力聚焦，专心完成某一个业务点的深度建设。</p><p>多个微服务系统之间通过 <code>RPC</code> 框架（如：dubbo、spring cloud、gRPC 等）完成了串联，但随着调用量越来越大，人们发现服务与服务之间的稳定性变得越来越重要</p><div align="left"><img src="'+p+'" width="650px"></div><p><strong>举个例子：</strong></p><ul><li>Service D 挂了，响应很慢</li><li>Service G 和 Service F ，都依赖 Service D，也会受到牵连，对外响应也会变慢</li><li>影响层层向上传递，Service A 和 Service B 也会被拖垮</li><li>最后，引发雪崩效应，系统的故障影响面会越来越大</li></ul><p>为了解决这种问题，我们需要引入 <code>熔断</code> 机制。 <strong>“当断则断，不受其乱。 当断不断，必受其难”</strong></p><h2 id="什么是熔断" tabindex="-1"><a class="header-anchor" href="#什么是熔断"><span>什么是熔断？</span></a></h2><p>熔断，其实是对调用链路中某个资源出现不稳定状态时（如：调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误。</p><p>当资源被降级后，在接下来的<code>降级时间窗口</code>内，对该资源的调用都自动熔断（默认是抛出 <code>BlockException</code>）</p><p>目前市面上的熔断框架很多，如：<code>Sentinel</code>、<code>Hystrix</code>、<code>Resilience4j</code> 等，这些框架的设计理念都差不多。</p><p>本文重点讲下 Sentinel 是如何在项目中使用的</p><p>Sentinel (分布式系统的流量防卫兵) 是阿里开源的一套用于服务容错的综合性解决方案。它以流量为切入点, 从<code>流量控制</code>、<code>熔断降级</code>、<code>系统负载保护</code>等多个维度来保护服务的稳定性。</p><h3 id="核心分为两部分" tabindex="-1"><a class="header-anchor" href="#核心分为两部分"><span>核心分为两部分</span></a></h3><p>1、核心库（Java 客户端）：能够运行在所有 Java 环境，对 Dubbo 、Spring Cloud 等框架也有较好的支持。</p><p>2、控制台（Dashboard）：基于 Spring Boot 开发，打包后可以直接运行。</p><h3 id="sentinel-熔断种类" tabindex="-1"><a class="header-anchor" href="#sentinel-熔断种类"><span>Sentinel 熔断种类</span></a></h3><ul><li>RT 响应时间</li><li>异常数</li><li>异常比例</li></ul><h2 id="sentinel-安装" tabindex="-1"><a class="header-anchor" href="#sentinel-安装"><span>Sentinel 安装</span></a></h2><p>首先，官网下载 sentinel 控制台安装包</p><blockquote><p>下载地址：<br><a href="https://github.com/alibaba/Sentinel/releases" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/Sentinel/releases</a></p></blockquote><p>下载 Jar 包后，打开终端，运行命令</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>java -Dserver.port=8180 -Dcsp.sentinel.dashboard.server=localhost:8180 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.1.jar</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="登陆sentinal控制台" tabindex="-1"><a class="header-anchor" href="#登陆sentinal控制台"><span>登陆Sentinal控制台</span></a></h3><div align="left"><img src="'+d+'" width="650px"></div><p>默认用户和密码都是 sentinel ，登录成功后的界面如下，先来个直观感受</p><div align="left"><img src="'+r+'" width="650px"></div><h3 id="控制台配置熔断规则" tabindex="-1"><a class="header-anchor" href="#控制台配置熔断规则"><span>控制台配置熔断规则</span></a></h3><div align="left"><img src="'+t+`" width="650px"></div><p>这里表示熔断策略选择 <code>慢调用比例</code>，响应时间超过200毫秒则标记为慢请求。如果在一个1000 ms的统计周期内（可自行调整），慢请求比例超过30%且数量超过3个，则对后续请求进行熔断，熔断时长为10秒钟，10秒以后恢复正常。</p><h3 id="注解式接入" tabindex="-1"><a class="header-anchor" href="#注解式接入"><span>注解式接入</span></a></h3><p>接入非常简单，只需要提前在控制台配置好<code>资源规则</code>，然后在代码中添加 <code>@SentinelResource</code>注解即可。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// 资源名称为handle1 </span></span>
<span class="line"><span>@RequestMapping(&quot;/handle1&quot;)</span></span>
<span class="line"><span>@SentinelResource(value = &quot;handle1&quot;, blockHandler = &quot;blockHandlerTestHandler&quot;)</span></span>
<span class="line"><span>public String handle1(String params) { </span></span>
<span class="line"><span>    // 业务逻辑处理</span></span>
<span class="line"><span>    return &quot;success&quot;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 接口方法 handle1 的 兜底方法</span></span>
<span class="line"><span>public String blockHandlerTestHandler(String params, BlockException blockException) {</span></span>
<span class="line"><span>    return &quot;兜底返回&quot;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>达到阈值后，系统的默认提示是一段英文，很不友好，我们可以<code>自定义兜底方法</code>。在<code>@SentinelResource</code>注解中进一步配置 <code>blockHandler</code>、<code>fallback</code> 属性字段</p><ul><li><code>blockHandler</code>：主观层面，如果被限流或熔断，则调用该方法，进行兜底处理</li><li><code>fallback</code>：对业务的异常兜底，比如，执行过程中抛了各种<code>Exception</code>，则调用该方法，进行兜底处理</li></ul><p>通过上面两层兜底，可以让<code>Sentinel</code> 框架更加人性化，体验更好。</p><blockquote><p>注意：注解式开发，需要添加在方法上，作用域范围相对固定。下面的项目实战中，我们也可以采用 <code>显示</code> 形式，可以灵活圈定代码块范围。</p></blockquote><h2 id="项目实战" tabindex="-1"><a class="header-anchor" href="#项目实战"><span>项目实战</span></a></h2><p>我们这边有个项目，考虑到客户的部署成本，想做一个轻量级方案，需求如下：</p><ul><li>既想引入框架的熔断功能，又不想部署控制台</li><li>拦截点相对收拢，类似与dubbo消费端远程访问一样，在代理类的远程通讯位置做拦截处理</li></ul><h3 id="概要方案-流程图" tabindex="-1"><a class="header-anchor" href="#概要方案-流程图"><span>概要方案--流程图</span></a></h3><div align="left"><img src="`+c+'" width="650px"></div><p>1、我们通过 <code>Proxy.newProxyInstance</code> 为所有的接口创建了代理子类</p><p>2、所有对代理子类的方法调用全部收拢到 <code>InvocationHandler</code></p><p>3、我们讲类名和方法名做一个拼接，然后去 <code>熔断规则表</code>查询，看是否配置了规则</p><p>4、如果没有，那么走常规则远程调用逻辑</p><p>5、如果有，将远程调用逻辑纳入 <code>Sentinel</code> 的监控管辖</p><p>6、如果触发了 熔断机制，则直接抛出 <code>BlockException</code> ，上层业务拦截异常，做特殊处理，比如：修饰下给用户更合适的文案提示。</p><h3 id="熔断状态机" tabindex="-1"><a class="header-anchor" href="#熔断状态机"><span>熔断状态机</span></a></h3><div align="left"><img src="'+o+`" width="650px"></div><p>核心的代码逻辑，继续往下看</p><h3 id="引入-sentinel-的依赖包" tabindex="-1"><a class="header-anchor" href="#引入-sentinel-的依赖包"><span>引入 Sentinel 的依赖包</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;!-- 限流、熔断框架 --&gt;</span></span>
<span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;sentinel-core&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;1.8.3&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="熔断规则表设计" tabindex="-1"><a class="header-anchor" href="#熔断规则表设计"><span>熔断规则表设计</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE \`degrade_rule\` (</span></span>
<span class="line"><span>  \`id\` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span></span>
<span class="line"><span>  \`resource_name\` varchar(256) NOT NULL COMMENT &#39;资源名称&#39;,</span></span>
<span class="line"><span>  \`count\` double NOT NULL COMMENT &#39;慢调用时长，单位 毫秒&#39;,</span></span>
<span class="line"><span>  \`slow_ratio_threshold\` double NOT NULL COMMENT &#39;慢调用比例阈值&#39;,</span></span>
<span class="line"><span>  \`min_request_amount\` int NOT NULL COMMENT &#39;熔断触发的最小请求数&#39;,</span></span>
<span class="line"><span>  \`stat_interval\` int NOT NULL COMMENT &#39;统计时长，单位 毫秒&#39;,</span></span>
<span class="line"><span>  \`time_window\` int NOT NULL COMMENT &#39;熔断时长，单位为 s&#39;,</span></span>
<span class="line"><span>  \`created_time\` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span></span>
<span class="line"><span>  \`updated_time\` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;修改时间&#39;,</span></span>
<span class="line"><span>  PRIMARY KEY (\`id\`) USING BTREE,</span></span>
<span class="line"><span>  UNIQUE KEY \`uk_resource_name\` (\`resource_name\`)</span></span>
<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb3 COMMENT=&#39;熔断规则表&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于放弃了部署控制台，我们只能自己管理熔断规则的各个属性值。可以按企业内部管理后台风格，开发页面管理这些规则。</p><p>当然，早期可以采用更简单粗暴方式，在数据库表手动初始化数据。如果要调整规则，走 SQL 订正。</p><p>为了尽可能实时感知规则表数据变更，开发了定时任务，每 10 秒运行一次。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Scheduled(cron = &quot;0/10 * * * * ? &quot;)</span></span>
<span class="line"><span>public void loadDegradeRule() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    List&lt;DegradeRuleDO&gt; degradeRuleDOList = degradeRuleDao.queryAllRule();</span></span>
<span class="line"><span>    if (CollectionUtils.isEmpty(degradeRuleDOList)) {</span></span>
<span class="line"><span>        return;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    String newMd5Hex = DigestUtils.md5Hex(JSON.toJSONString(degradeRuleDOList));</span></span>
<span class="line"><span>    if (StringUtils.isBlank(newMd5Hex) || StringUtils.equals(lastMd5Hex, newMd5Hex)) {</span></span>
<span class="line"><span>        return;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    List&lt;DegradeRule&gt; rules = null;</span></span>
<span class="line"><span>    List&lt;String&gt; resourceNameList = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>    rules = degradeRuleDOList.stream().map(degradeRuleDO -&gt; {</span></span>
<span class="line"><span>         //资源名，即规则的作用对象</span></span>
<span class="line"><span>        DegradeRule rule = new DegradeRule(degradeRuleDO.getResourceName()) </span></span>
<span class="line"><span>                // 熔断策略，支持慢调用比例/异常比例/异常数策略</span></span>
<span class="line"><span>                .setGrade(CircuitBreakerStrategy.SLOW_REQUEST_RATIO.getType())</span></span>
<span class="line"><span>                //慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例/异常数模式下为对应的阈值</span></span>
<span class="line"><span>                .setCount(degradeRuleDO.getCount())</span></span>
<span class="line"><span>                // 熔断时长，单位为 s</span></span>
<span class="line"><span>                .setTimeWindow(degradeRuleDO.getTimeWindow())</span></span>
<span class="line"><span>                // 慢调用比例阈值</span></span>
<span class="line"><span>                .setSlowRatioThreshold(degradeRuleDO.getSlowRatioThreshold())</span></span>
<span class="line"><span>                //熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断</span></span>
<span class="line"><span>                .setMinRequestAmount(degradeRuleDO.getMinRequestAmount())</span></span>
<span class="line"><span>                //统计时长（单位为 ms）</span></span>
<span class="line"><span>                .setStatIntervalMs(degradeRuleDO.getStatInterval());</span></span>
<span class="line"><span>        resourceNameList.add(degradeRuleDO.getResourceName());</span></span>
<span class="line"><span>        return rule;</span></span>
<span class="line"><span>    }).collect(Collectors.toList());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (CollectionUtils.isNotEmpty(rules)) {</span></span>
<span class="line"><span>        DegradeRuleManager.loadRules(rules);</span></span>
<span class="line"><span>        ConsumerProxyFactory.resourceNameList = resourceNameList;</span></span>
<span class="line"><span>        lastMd5Hex = newMd5Hex;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    log.error(&quot;[DegradeRuleConfig] 熔断规则加载: &quot; + rules);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>考虑到规则变更频率不会很高，没有必要每次都<code>DegradeRuleManager.loadRules</code>重新加载规则。这里设计了个小窍门</p><p><code>DigestUtils.md5Hex(JSON.toJSONString(degradeRuleDOList));</code></p><p>对查询的规则内容 <code>JSON</code> 序列化，然后计算其md5摘要，如果跟上一次的结果一致，说明这期间没有变更，直接 return ，不做处理。</p><p>定义子类，实现了 <code>InvocationHandler</code> 接口。通过 <code>Proxy.newProxyInstance</code> 为目标接口创建一个代理子类。</p><p>这样，每次调用接口方法，实际都是在调用 <code>invoke</code> 方法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Override</span></span>
<span class="line"><span>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {</span></span>
<span class="line"><span>	Class&lt;?&gt; clazz = proxy.getClass().getInterfaces()[0];</span></span>
<span class="line"><span>	String urlCode = clazz.getName() + &quot;#&quot; + method.getName();</span></span>
<span class="line"><span>	if (resourceNameList.contains(urlCode)) {</span></span>
<span class="line"><span>        // 增加熔断处理</span></span>
<span class="line"><span>        Entry entry = null;</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            entry = SphU.entry(urlCode);</span></span>
<span class="line"><span>            // 远程网络调用，获取结果</span></span>
<span class="line"><span>            responseString = HttpClientUtil.postJsonRequest(url, header, body);</span></span>
<span class="line"><span>        } catch (BlockException blockException) {</span></span>
<span class="line"><span>            // 触发熔断</span></span>
<span class="line"><span>            log.error(&quot;degrade trigger !  remote url :{} &quot;, urlCode);</span></span>
<span class="line"><span>            throw new DegradeBlockExcetion(urlCode);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            if (entry != null) {</span></span>
<span class="line"><span>                entry.exit();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } </span></span>
<span class="line"><span>     } else {</span></span>
<span class="line"><span>          // 常规处理，不走熔断判断逻辑</span></span>
<span class="line"><span>          // 省略</span></span>
<span class="line"><span>    }    </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="测试数据" tabindex="-1"><a class="header-anchor" href="#测试数据"><span>测试数据</span></a></h3><div align="left"><img src="`+u+'" width="800px"></div><blockquote><p>上面案例的源代码已经上传到 GitHub，关注公众号：老马啸西风，回复关键词：「1819」 即可获取</p></blockquote>',75)]))}const E=n(v,[["render",b]]),k=JSON.parse('{"path":"/posts/interview/arch/system/%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E5%A4%A7%E9%87%8F%E8%B6%85%E6%97%B6%EF%BC%8C%E6%8A%8A%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%8B%96%E5%9E%AE%EF%BC%8C%E5%BC%95%E5%8F%91%E9%9B%AA%E5%B4%A9%EF%BC%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E7%86%94%E6%96%AD.html","title":"外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断...","lang":"zh-CN","frontmatter":{"title":"外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断...","description":"外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断... 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 大家好，我是老马~ 互联网+ 时代，业务数字化已经蔓延到你能想到的各个行业。各种业务功能、营销玩法越来越多，系统也越来越复杂。 面对不断复杂的业务系统，脑子越来越不够用了 于是 聪...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/system/%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E5%A4%A7%E9%87%8F%E8%B6%85%E6%97%B6%EF%BC%8C%E6%8A%8A%E6%95%B4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%8B%96%E5%9E%AE%EF%BC%8C%E5%BC%95%E5%8F%91%E9%9B%AA%E5%B4%A9%EF%BC%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F%E7%86%94%E6%96%AD.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断..."}],["meta",{"property":"og:description","content":"外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断... 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 大家好，我是老马~ 互联网+ 时代，业务数字化已经蔓延到你能想到的各个行业。各种业务功能、营销玩法越来越多，系统也越来越复杂。 面对不断复杂的业务系统，脑子越来越不够用了 于是 聪..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断...\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":7.66,"words":2299},"filePathRelative":"posts/interview/arch/system/外部接口大量超时，把整个系统拖垮，引发雪崩！如何解决？熔断.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>大家好，我是老马~</p>\\n<p>互联网+ 时代，业务数字化已经蔓延到你能想到的各个行业。各种业务功能、营销玩法越来越多，系统也越来越复杂。</p>\\n<p>面对不断复杂的业务系统，脑子越来越不够用了</p>","autoDesc":true}');export{E as comp,k as data};
