import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as r,o as s}from"./app-NomDibRt.js";const t="/vpress/images/middleware/mq/30-1.jpg",o="/vpress/images/middleware/mq/30-2.jpg",n="/vpress/images/middleware/mq/30-3.jpg",p="/vpress/images/middleware/mq/30-4.jpg",d="/vpress/images/middleware/mq/30-5.jpg",c="/vpress/images/middleware/mq/30-6.jpg",l="/vpress/images/middleware/mq/30-7.jpg",h={};function m(b,e){return s(),i("div",null,e[0]||(e[0]=[r('<h1 id="kafka-如何解决消息不丢失" tabindex="-1"><a class="header-anchor" href="#kafka-如何解决消息不丢失"><span>Kafka 如何解决消息不丢失？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>Kafka 消息框架，大家一定不陌生，很多人工作中都有接触。它的核心思路，通过一个高性能的<code>MQ服务</code>来连接<code>生产</code>和<code>消费</code>两个系统，达到系统间的解耦，有很强的扩展性。</p><div align="left"><img src="'+t+'" width="650px"></div><p>你可能会有疑问，如果中间某一个环节断掉了，那怎么办？</p><div align="left"><img src="'+o+'" width="650px"></div><p>这种情况，我们称之为<code>消息丢失</code>，会造成系统间的数据不一致。</p><p>那如何解决这个问题？需要从<code>生产端</code>、<code>MQ服务端</code>、<code>消费端</code>，三个维度来处理</p><h2 id="_1、生产端" tabindex="-1"><a class="header-anchor" href="#_1、生产端"><span>1、生产端</span></a></h2><p>生产端的职责就是，确保生产的消息能到达MQ服务端，这里我们需要有一个响应来判断本次的操作是否成功。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Future&lt;RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>比如，上面的代码就是通过一个<code>Callback</code>函数，来判断消息是否发送成功，如果失败，我们需要补偿处理。</p><p>另外，为了提升发送时的灵活性，kafka提供了多种参数，供不同业务自己选择</p><h3 id="_1-1-参数-acks" tabindex="-1"><a class="header-anchor" href="#_1-1-参数-acks"><span>1.1 参数 acks</span></a></h3><p>该参数表示有多少个分区副本收到消息，才认为本次发送是成功的。</p><ul><li>acks=0，只要发送消息就认为成功，生产端不等待服务器节点的响应</li><li>acks=1，表示生产者收到 leader 分区的响应就认为发送成功</li><li>acks=-1，只有当 ISR 中的副本全部收到消息时，生产端才会认为是成功的。这种配置是最安全的，但由于同步的节点较多，吞吐量会降低。</li></ul><h3 id="_1-2-参数-retries" tabindex="-1"><a class="header-anchor" href="#_1-2-参数-retries"><span>1.2 参数 retries</span></a></h3><p>表示生产端的重试次数，如果重试次数用完后，还是失败，会将消息临时存储在本地磁盘，待服务恢复后再重新发送。建议值 <code>retries=3 </code></p><h3 id="_1-3-参数-retry-backoff-m" tabindex="-1"><a class="header-anchor" href="#_1-3-参数-retry-backoff-m"><span>1.3 参数 retry.backoff.m</span></a></h3><p>消息发送超时或失败后，间隔的重试时间。一般推荐的设置时间是 300 毫秒。</p><p>这里要特别注意一种特殊情况，如果MQ服务没有正常响应，不一定代表<code>消息发送失败</code>，也有可能是响应时正好赶上网络抖动，响应超时。</p><div align="left"><img src="'+n+'" width="650px"></div><p><strong>当生产端做完这些，一定能保证消息发送成功了，但可能发送多次，这样就会导致消息重复，这个我们后面再讲解决方案</strong></p><h2 id="_2、mq服务端" tabindex="-1"><a class="header-anchor" href="#_2、mq服务端"><span>2、MQ服务端</span></a></h2><p>MQ服务端作为消息的存储介质，也有可能会丢失消息。比如：一个分区突然挂掉，那么怎么保证这个分区的数据不丢失，我们会引入副本概念，通过备份来解决这个问题。</p><p>具体可设置哪些参数？</p><h3 id="_2-1-参数-replication-factor" tabindex="-1"><a class="header-anchor" href="#_2-1-参数-replication-factor"><span>2.1 参数 replication.factor</span></a></h3><p>表示分区副本的个数，<code> replication.factor &gt;1</code> 当leader 副本挂了，follower副本会被选举为leader继续提供服务。</p><h3 id="_2-2-参数-min-insync-replicas" tabindex="-1"><a class="header-anchor" href="#_2-2-参数-min-insync-replicas"><span>2.2 参数 min.insync.replicas</span></a></h3><p>表示 ISR 最少的副本数量，通常设置 <code>min.insync.replicas &gt;1</code>，这样才有可用的follower副本执行替换，保证消息不丢失</p><h3 id="_2-3-参数-unclean-leader-election-enable" tabindex="-1"><a class="header-anchor" href="#_2-3-参数-unclean-leader-election-enable"><span>2.3 参数 unclean.leader.election.enable</span></a></h3><p>是否可以把非 ISR 集合中的副本选举为 leader 副本。</p><p>如果设置为<code>true</code>，而follower副本的同步消息进度落后较多，此时被选举为leader，会导致消息丢失，慎用。</p><div align="left"><img src="'+p+'" width="650px"></div><h2 id="_3、消费端" tabindex="-1"><a class="header-anchor" href="#_3、消费端"><span>3、消费端</span></a></h2><p>消费端要做的是把消息完整的消费处理掉。但是这里面有个<code>提交位移</code>的步骤。</p><div align="left"><img src="'+d+`" width="650px"></div><p>有的同学，考虑到<code>业务处理</code>消耗时间较长，会单独启动线程拉取消息存储到本地内存队列，然后再搞个线程池并行处理业务逻辑。这样设计有个风险，本地消息如果没有处理完，服务器宕机了，会造成消息丢失。</p><p><strong>正确的做法：拉取消息 --- 业务处理 ---- 提交消费位移</strong></p><p>关于提交位移，kafka提供了集中参数配置</p><p><strong>参数 enable.auto.commit</strong></p><p>表示消费位移是否自动提交。</p><p>如果拉取了消息，业务逻辑还没处理完，提交了消费位移但是消费端却挂了，消费端恢复或其他消费端接管该分片再也拉取不到这条消息，会造成消息丢失。所以，我们通常设置 <code>enable.auto.commit=false</code>，手动提交消费位移。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>List&lt;String&gt; messages = consumer.poll()；</span></span>
<span class="line"><span>processMsg(messages);</span></span>
<span class="line"><span>consumer.commitOffset();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方案，会产生另外一个问题，我们来看下这个图</p><div align="left"><img src="`+c+'" width="650px"></div><p>拉取了<code>消息4~消息8</code>，业务处理后，在提交消费位移时，不凑巧系统宕机了，最后的提交位移并没有保存到MQ 服务端，下次拉取消息时，依然是从<code>消息4</code>开始拉取，但是这部分消息已经处理过了，这样便会导致重复消费。</p><h2 id="如何解决重复消费-避免引发数据不一致" tabindex="-1"><a class="header-anchor" href="#如何解决重复消费-避免引发数据不一致"><span>如何解决重复消费，避免引发数据不一致</span></a></h2><p>首先，要解决MQ 服务端的重复消息。kafka 在 0.11.0 版本后，每条消息都有唯一的message id, MQ服务采用空间换时间方式，自动对重复消息过滤处理，保证接口的幂等性。</p><div align="left"><img src="'+l+'" width="650px"></div><p>但这个不能根本上解决消息重复问题，即使MQ服务中存储的消息没有重复，但消费端是采用拉取方式，如果重复拉取，也会导致<code>重复消费</code>，如何解决这种场景问题？</p><p>方案一：只拉取一次（<code>消费者拉取消息后，先提交 offset 后再处理消息</code>），但是如果系统宕机，业务处理没有正常结束，后面再也拉取不到这些消息，会导致数据不一致，该方案很少采用。</p><p>方案二：允许拉取重复消息，但是消费端自己做幂等性控制。保证只<code>成功消费一次</code>。</p><p>关于幂等技术方案很多，我们可以采用<code>数据表</code>或<code>Redis缓存</code>存储处理标识，每次拉取到消息，处理前先校验处理状态，再决定是处理还是丢弃消息。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=1047&amp;sid=20-h5Url-0&amp;buyFrom=1&amp;pageId=1pz4#/detail/pc?id=8070" target="_blank" rel="noopener noreferrer">Kafka 是如何做到消息不丢或不重复的？</a></li></ul>',57)]))}const u=a(h,[["render",m]]),k=JSON.parse('{"path":"/posts/interview/middleware/mq/Kafka%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F.html","title":"Kafka 如何解决消息不丢失？","lang":"zh-CN","frontmatter":{"title":"Kafka 如何解决消息不丢失？","description":"Kafka 如何解决消息不丢失？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 Kafka 消息框架，大家一定不陌生，很多人工作中都有接触。它的核心思路，通过一个高性能的MQ服务来连接生产和消费两个系统，达到系统间的解耦，有很强的扩展性。 你可能会有疑问，如果中间某一个环节断掉了，那怎...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mq/Kafka%20%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Kafka 如何解决消息不丢失？"}],["meta",{"property":"og:description","content":"Kafka 如何解决消息不丢失？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 Kafka 消息框架，大家一定不陌生，很多人工作中都有接触。它的核心思路，通过一个高性能的MQ服务来连接生产和消费两个系统，达到系统间的解耦，有很强的扩展性。 你可能会有疑问，如果中间某一个环节断掉了，那怎..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kafka 如何解决消息不丢失？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":5.5,"words":1649},"filePathRelative":"posts/interview/middleware/mq/Kafka 如何解决消息不丢失？.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>Kafka 消息框架，大家一定不陌生，很多人工作中都有接触。它的核心思路，通过一个高性能的<code>MQ服务</code>来连接<code>生产</code>和<code>消费</code>两个系统，达到系统间的解耦，有很强的扩展性。</p>","autoDesc":true}');export{u as comp,k as data};
