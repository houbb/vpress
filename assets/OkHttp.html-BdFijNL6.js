import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-NomDibRt.js";const t={};function l(p,s){return i(),e("div",null,s[0]||(s[0]=[a(`<h1 id="spring-boot-集成-okhttp" tabindex="-1"><a class="header-anchor" href="#spring-boot-集成-okhttp"><span>Spring Boot 集成 OkHttp</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>OKHttp 是 Square 公司开发的一款网络框架，其设计和实现的目的就是高效。OkHttp框架完整的实现了 HTTP 协议，支持的协议有 HTTP/1.1、SPDY、HTTP/2.0 。在 Android 4.4 的源码中HttpURLConnection 已经被替换成OkHttp。</p><p>既然 OkHttp 的招牌是高效，那它是如何实现的呢？</p><ul><li>采用连接池技术减少</li><li>默认使用 GZIP 数据压缩格式，降低传输内容的大小</li><li>采用缓存避免重复的网络请求</li><li>支持SPDY、HTTP/2.0，对于同一主机的请求可共享同一socket连接</li><li>若SPDY或HTTP/2.0 不可用，还会采用连接池提高连接效率</li><li>网络出现问题、会自动重连（尝试连接同一主机的多个ip地址）</li><li>使用 okio 库简化数据的访问和存储</li></ul><h2 id="常用概念" tabindex="-1"><a class="header-anchor" href="#常用概念"><span>常用概念</span></a></h2><h3 id="okhttpclient" tabindex="-1"><a class="header-anchor" href="#okhttpclient"><span>OkHttpClient</span></a></h3><p>OkHttpClient 可以说是整个OkHttp 框架的一个门面（Facade 模式），在使用 OkHttp 框架时只需同OkHttpClient 打交道，而不用考虑其内部复杂的构成。这个类的职责就是配置参数和生成 Call 对象，配置参数包括：超时时间（连接、读、写）、代理服务器、Dns、协议和连接规范、缓存配置，拦截器、证书验证等。</p><h3 id="request" tabindex="-1"><a class="header-anchor" href="#request"><span>Request</span></a></h3><p>Request 是 一个基本的 HTTP 网络请求，包括要请求的URL，同 HTTP 规范一样，它需要包含请求行，请求头，请求体（可以为空）。</p><h3 id="response" tabindex="-1"><a class="header-anchor" href="#response"><span>Response</span></a></h3><p>Response 即为网络响应，包括响应行，响应头和响应体（允许为空）, 响应体只能被消费一次，且除响应体外的属性不可变。</p><h3 id="call" tabindex="-1"><a class="header-anchor" href="#call"><span>Call</span></a></h3><p>Call 是一个接口，实现了对 Request 的封装，可以看做是一次请求任务，可以同步(execute)、异步(enqueue)执行，也可以取消 (cancel) 或者查询当前任务状态 。RealCall 是 Call 的一个子类，对其接口中定义的方法做了实现。</p><p><strong>Cache &amp; CacheStrategy</strong></p><p>Cache 即缓存，是对于某一特定 Request 的缓存，缓存的内容为该 Request 的 Response ，缓存多以&lt;请求、响应&gt;键值对的形式存在。缓存可以为内存，也可以为硬盘，缓存可以进行失效时间、最大容量、缓存目录等设置。<br> CacheStrategy 即缓存策略，即当用 OkHttp 请求一个 Request 时，是采用缓存还是网络还是两者皆用。</p><h2 id="核心流程" tabindex="-1"><a class="header-anchor" href="#核心流程"><span>核心流程</span></a></h2><ul><li>构建<code>OkHttpClient</code>对象</li><li>构建<code>Request</code>对象</li><li>由前两步创建的<code>OkHttpClient</code>和<code>Request</code>对象创建<code>Call</code>对象</li><li>通过<code>Call</code>对象发起请求，并得到一个<code>Response</code>对象，解析得到最终返回的结果。</li></ul><h2 id="代码演示" tabindex="-1"><a class="header-anchor" href="#代码演示"><span>代码演示</span></a></h2><p>在pom.xml中添加以下依赖项：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;</span></span>
<span class="line"><span>    &lt;version&gt;3.10.0&lt;/version&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>官方建议是一个工程只配置一个 OKHttpClient 来处理所有的网络请求。</p></blockquote><p>初始化 <code>OkHttpClient</code> 客户端实例</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>client = new OkHttpClient.Builder()</span></span>
<span class="line"><span>        .connectTimeout(connTimeout, TimeUnit.MILLISECONDS)</span></span>
<span class="line"><span>        .readTimeout(readTimeout, TimeUnit.MILLISECONDS)</span></span>
<span class="line"><span>        .writeTimeout(writeTime, TimeUnit.MILLISECONDS)</span></span>
<span class="line"><span>        .sslSocketFactory(createSslSocketFactory(), x509TrustManager())</span></span>
<span class="line"><span>        .connectionPool(createConnectionPool())</span></span>
<span class="line"><span>        .build();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发送post请求</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>public static String post(String url, String message, Map&lt;String, String&gt; headers) {</span></span>
<span class="line"><span>    RequestBody requestBody = RequestBody.create(JSON_TYPE, message);</span></span>
<span class="line"><span>    Builder builder = new Builder();</span></span>
<span class="line"><span>    builder.url(url).post(requestBody).build();</span></span>
<span class="line"><span>    Response response = null;</span></span>
<span class="line"><span>    String result = &quot;&quot;;</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        // 添加header</span></span>
<span class="line"><span>        if (headers != null &amp;&amp; !headers.isEmpty()) {</span></span>
<span class="line"><span>            Iterator iterator = headers.entrySet().iterator();</span></span>
<span class="line"><span>            while (iterator.hasNext()) {</span></span>
<span class="line"><span>                Map.Entry entry = (Map.Entry) iterator.next();</span></span>
<span class="line"><span>                builder.addHeader((String) entry.getKey(), (String) entry.getValue());</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Request request = builder.build();</span></span>
<span class="line"><span>        response = client.newCall(request).execute();</span></span>
<span class="line"><span>        if (response.code() == 200) {</span></span>
<span class="line"><span>            result = response.body() == null ? &quot;&quot; : response.body().string();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    } catch (IOException var3) {</span></span>
<span class="line"><span>        log.error(&quot;[HttpPost JSON Exception] URL:{}, error:{}&quot;, url, var3);</span></span>
<span class="line"><span>        throw new RuntimeException(var3);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        if (response != null) {</span></span>
<span class="line"><span>            response.close();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return result;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>同步请求使用的是call.execute()，只有当整个请求完成时才会从.execute()方法返回。</p></blockquote><blockquote><p>而对于异步请求来说，.enqueue(Callback)方法只要调用完就立即返回了，当网络请求返回之后会回调Callback的onResponse/onFailure方法，并且这两个回调方法是在子线程执行的，这也是异步请求和同步请求之间最主要的差别。</p></blockquote><p>本地跑单元测试，发送post模拟请求，请求参数采用<code>json</code>格式数据，<code>content-type = &quot;application/json;charset=utf-8&quot;</code></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Test</span></span>
<span class="line"><span>public void queryUser() {</span></span>
<span class="line"><span>    User user = User.builder().userName(&quot;TomGE&quot;).age(29).address(&quot;北京&quot;).build();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    String url = &quot;http://localhost:8090/queryUser&quot;;</span></span>
<span class="line"><span>    String requestJson = JSON.toJSONString(user);</span></span>
<span class="line"><span>//        System.out.println(requestJson);</span></span>
<span class="line"><span>    String result = OkHttpUtil.post(url, requestJson, null);</span></span>
<span class="line"><span>    System.out.println(&quot;响应结果：&quot;);</span></span>
<span class="line"><span>    System.out.println(result);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>响应结果：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>已经接收到请求，用户名：TomGE , 年龄：29 , 地址：北京。响应：sucess!</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="项目源码" tabindex="-1"><a class="header-anchor" href="#项目源码"><span>项目源码</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://github.com/aalansehaiyang/spring-boot-bulking  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>模块：spring-boot-bulking-okhttp</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,36)]))}const d=n(t,[["render",l]]),c=JSON.parse('{"path":"/posts/interview/spring/springboot/OkHttp.html","title":"Spring Boot 集成 OkHttp","lang":"zh-CN","frontmatter":{"title":"Spring Boot 集成 OkHttp","description":"Spring Boot 集成 OkHttp 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/spring/springboot/OkHttp.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Spring Boot 集成 OkHttp"}],["meta",{"property":"og:description","content":"Spring Boot 集成 OkHttp 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring Boot 集成 OkHttp\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":3.95,"words":1184},"filePathRelative":"posts/interview/spring/springboot/OkHttp.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p>","autoDesc":true}');export{d as comp,c as data};
