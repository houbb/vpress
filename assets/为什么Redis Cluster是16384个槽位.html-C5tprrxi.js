import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as s,o as r}from"./app-NomDibRt.js";const p="/vpress/images/middleware/redis/33-1.jpeg",o="/vpress/images/middleware/redis/33-6.jpeg",a="/vpress/images/middleware/redis/33-2.jpeg",d="/vpress/images/middleware/redis/33-3.jpeg",n="/vpress/images/middleware/redis/33-4.jpeg",l="/vpress/images/middleware/redis/33-5.jpeg",c={};function h(u,e){return r(),t("div",null,e[0]||(e[0]=[s('<h1 id="为什么-redis-cluster-是16384个槽位" tabindex="-1"><a class="header-anchor" href="#为什么-redis-cluster-是16384个槽位"><span>为什么 Redis Cluster 是16384个槽位?</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>我们都知道Redis的集群有三种方案：</p><ul><li>1、主从复制模式</li><li>2、Sentinel（哨兵）模式</li><li>3、Redis Cluster模式</li></ul><p>当然使用随着海量数据的存储要求，单台Redis配置有限，已经满足不了我们的需求。我们考虑采用<strong>分布式集群方案</strong>。</p><p>Redis Cluster 采用数据分片机制，定义了 16384个 Slot槽位，集群中的每个Redis 实例负责维护一部分槽以及槽所映射的键值数据。</p><p><strong>客户端可以连接集群中任意一个Redis 实例，发送读写命令，如果当前Redis 实例收到不是自己负责的Slot的请求时，会将改slot所在的正确的Redis 实例地址返回给客户端。</strong></p><p><strong>客户端收到后，自动将原请求重新发到这个新地址，自动操作，外部透明。</strong></p><div align="left"><img src="'+p+'" width="300px"></div><p>是不是有点似曾相识的感觉，HTTP 协议也有重定向功能。玩法跟这个差不多。HTTP 响应头有一个<code>Location</code>字段，当状态码是<code>301</code>或者<code>302</code>时，客户端会自动读取 <code>Location</code>中的新地址，自动重定向发送请求。</p><blockquote><p>Redis key的路由计算公式：slot = CRC16（key） % 16384</p></blockquote><p>添加、删除或者修改某一个节点，都不会造成集群不可用的状态。使用哈希槽的好处就在于可以方便的添加或移除节点。</p><p>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点；当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点。</p><div align="left"><img src="'+o+'" width="560px"></div><h2 id="crc16的算法原理" tabindex="-1"><a class="header-anchor" href="#crc16的算法原理"><span>CRC16的算法原理</span></a></h2><ul><li>根据CRC16的标准选择初值CRCIn的值</li><li>将数据的第一个字节与CRCIn高8位异或</li><li>判断最高位，若该位为 0 左移一位，若为 1 左移一位再与多项式Hex码异或</li><li>重复3直至8位全部移位计算结束。</li><li>重复将所有输入数据操作完成以上步骤，所得16位数即16位CRC校验码。</li></ul><h2 id="crc16-算法最大值" tabindex="-1"><a class="header-anchor" href="#crc16-算法最大值"><span>CRC16 算法最大值</span></a></h2><p>CRC16 算法，产生的hash值有 16 bit 位，可以产生 65536（2^16）个值 ，也就是说值分布在 0 ~ 65535 之间</p><h2 id="疑问来了-槽位总数为什么是-16384-65536-不可以吗" tabindex="-1"><a class="header-anchor" href="#疑问来了-槽位总数为什么是-16384-65536-不可以吗"><span>疑问来了，槽位总数为什么是 16384 ？ 65536 不可以吗？</span></a></h2><div align="left"><img src="'+a+'" width="300px"></div><p>这个问题，Redis 官方 Issues 也有朋友提出来过</p><blockquote><p>地址：<a href="https://github.com/redis/redis/issues/2576" target="_blank" rel="noopener noreferrer">https://github.com/redis/redis/issues/2576</a></p></blockquote><div align="left"><img src="'+d+'" width="560px"></div><p><code>antirez</code> 大神对这个问题做了回复，简单归纳起来，有以下原因：</p><ul><li><p>正常的心跳数据包携带节点的完整配置，它能以幂等方式来更新配置。如果采用 16384 个插槽，占空间 2KB （16384/8）；如果采用 65536 个插槽，占空间 8KB (65536/8)。</p></li><li><p>Redis Cluster 不太可能扩展到超过 1000 个主节点，太多可能导致网络拥堵。</p></li><li><p>16384 个插槽范围比较合适，当集群扩展到1000个节点时，也能确保每个master节点有足够的插槽，</p></li></ul><p>8KB 的心跳包看似不大，但是这个是心跳包每秒都要将本节点的信息同步给集群其他节点。比起 16384 个插槽，头大小增加了4倍，ping消息的消息头太大了，浪费带宽。</p><p>Redis主节点的哈希槽配置信息是通过 <code>bitmap</code> 来保存的</p><div align="left"><img src="'+n+'" width="560px"></div><p>传输过程中，会对bitmap进行压缩，bitmap的填充率越低，压缩率越高。</p><blockquote><p>bitmap 填充率 = slots / N (N表示节点数)，</p></blockquote><p>所以，插槽数偏低的话， 填充率会降低，压缩率会升高。</p><p>综合下来，从心跳包的大小、网络带宽、心跳并发、压缩率等维度考虑，16384 个插槽更有优势且能满足业务需求。</p><p>万事万物，都是相互制衡的，”大“ 不一定是最好的，合适最重要。</p><h2 id="master节点间心跳数据包格式" tabindex="-1"><a class="header-anchor" href="#master节点间心跳数据包格式"><span>master节点间心跳数据包格式</span></a></h2><p>消息格式分为：消息头和消息体。消息头包含发送节点自身状态数据，接收节点根据消息头就可以获取到发送节点的相关数据，代码位置：<code>/usr/src/redis/redis-5.0.7/src/cluster.h</code></p><div align="left"><img src="'+l+'" width="560px"></div><p>其中，消息头有一个myslots的char类型数组，<code>unsigned char myslots[CLUSTER_SLOTS/8];</code>，数组长度为 16384/8 = 2048 。底层存储其实是一个bitmap，每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点。</p><p>消息体中，会携带一定数量的其他节点信息用于交换，约为集群总节点数量的1/10，节点数量越多，消息体内容越大。10个节点的消息体大小约1kb。</p><h2 id="划重点" tabindex="-1"><a class="header-anchor" href="#划重点"><span>划重点</span></a></h2><p>细心的同学可能会有疑问，char不是占2个字节吗？数组长度为什么是 16384/8？不应该是 16384/16 吗？</p><p>因为，Redis 是 C 语言开发的，char 占用一个 字节； 而 Java 语言 char 占用 两个 字节。</p><p><strong>master节点间心跳通讯</strong></p><p>Redis 集群采用 Gossip（流言）协议， Gossip 协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，类似流言传播。</p><blockquote><p>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，只要这些节点彼此可以正常通信，最终它们会达到一致的状态。当节点出现故障、新节点加入、主从角色变化、槽信息变更等事件发生时，通过不断的 ping/pong 消息通信，经过一段时间后所有的节点都会知道整个集群 全部节点的最新状态，从而达到集群状态同步的目的。</p></blockquote><p>具体规则如下：</p><ul><li>1、每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息</li><li>2、每隔 100毫秒 都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2 ，则立刻发送ping消息</li></ul><p>因此，每秒单master节点发出ping消息数量：</p><blockquote><p>数量 = 1 + 10 * num（node.pong_received&gt;cluster_node_timeout/2）</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>1、每秒 redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为 65536，这个ping消息的消息头太大了，浪费带宽。</p><p>2、业务上看，集群主节点数量基本不可能超过1000个。集群节点越多，心跳包的消息体携带的数据越多。如果节点超过1000个，会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。</p><p>3、槽位越小，节点少的情况下，压缩率更高</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://github.com/will-yinchengxin/redis/blob/99da9ae94c4bb8dac4c02962090420558603b588/10redis%E9%9B%86%E7%BE%A4%E8%AF%A6%E6%83%85.md" target="_blank" rel="noopener noreferrer">10redis集群详情.md</a></li></ul>',55)]))}const g=i(c,[["render",h]]),R=JSON.parse('{"path":"/posts/interview/middleware/redis/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%20Cluster%E6%98%AF16384%E4%B8%AA%E6%A7%BD%E4%BD%8D.html","title":"为什么 Redis Cluster 是16384个槽位?","lang":"zh-CN","frontmatter":{"title":"为什么 Redis Cluster 是16384个槽位?","description":"为什么 Redis Cluster 是16384个槽位? 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们都知道Redis的集群有三种方案： 1、主从复制模式 2、Sentinel（哨兵）模式 3、Redis Cluster模式 当然使用随着海量数据的存储要求，单台Redis配置有限...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/redis/%E4%B8%BA%E4%BB%80%E4%B9%88Redis%20Cluster%E6%98%AF16384%E4%B8%AA%E6%A7%BD%E4%BD%8D.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"为什么 Redis Cluster 是16384个槽位?"}],["meta",{"property":"og:description","content":"为什么 Redis Cluster 是16384个槽位? 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们都知道Redis的集群有三种方案： 1、主从复制模式 2、Sentinel（哨兵）模式 3、Redis Cluster模式 当然使用随着海量数据的存储要求，单台Redis配置有限..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么 Redis Cluster 是16384个槽位?\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":5.98,"words":1793},"filePathRelative":"posts/interview/middleware/redis/为什么Redis Cluster是16384个槽位.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>我们都知道Redis的集群有三种方案：</p>\\n<ul>\\n<li>1、主从复制模式</li>\\n<li>2、Sentinel（哨兵）模式</li>\\n<li>3、Redis Cluster模式</li>\\n</ul>","autoDesc":true}');export{g as comp,R as data};
