import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as t,o as s}from"./app-NomDibRt.js";const p="/vpress/images/arch/case/1-1.png",r="/vpress/images/arch/case/1-2.png",o="/vpress/images/arch/case/1-3.png",n="/vpress/images/arch/case/1-4.png",c="/vpress/images/arch/case/1-5.png",d="/vpress/images/arch/case/1-6.png",h="/vpress/images/arch/case/1-7.png",l="/vpress/images/arch/case/1-8.png",b={};function m(u,e){return s(),a("div",null,e[0]||(e[0]=[t('<h1 id="如何设计一个-redis-分布式锁" tabindex="-1"><a class="header-anchor" href="#如何设计一个-redis-分布式锁"><span>如何设计一个 Redis 分布式锁？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>多线程并发在我们做系统架构设计中经常遇到，例如：抽奖、秒杀、库存 等。</p><p>面对多个请求同时对一个<code>共享资源</code> 修改，如何保证数据安全，这里就需要引入 <code>锁</code> 来解决临界资源的访问安全。</p><p>JDK 中提供了 <code>synchronized</code> 和 <code>Lock</code> 两种锁。</p><p>无论哪一种锁，有一个前提条件，都是解决同一个 JVM 进程下的线程安全问题。</p><p>面对当下分布式微服务系统架构，多个系统，多台机器，多个进程，JDK 提供的锁已经无法解决这个问题。</p><p>这时，我们需要一个分布式锁</p><blockquote><p>在实现 JVM 锁时，我们将锁的状态保存在 Java 的对象头中，分布式锁也是类似的道理，将锁的状态保存在一个外部存储，比如：MySQL、Redis 等存储服务中。</p></blockquote><h2 id="一、分布式锁都要考虑哪些因素" tabindex="-1"><a class="header-anchor" href="#一、分布式锁都要考虑哪些因素"><span>一、分布式锁都要考虑哪些因素？</span></a></h2><p>1、互斥性，这个是锁的最基本要求<br> 2、可重入性，同一个线程可以重复多次获得锁<br> 3、支持阻塞、非阻塞两种特性<br> 4、支持锁超时，为了防止线程意外退出，没有正常释放锁，导致其他线程无法正常获取到锁。加锁时间超过一定时间，会自动释放锁</p><h2 id="二、redis-实现分布式锁" tabindex="-1"><a class="header-anchor" href="#二、redis-实现分布式锁"><span>二、Redis 实现分布式锁</span></a></h2><p>加锁通常使用 set 命令来实现，伪代码如下</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>set key value PX milliseconds NX</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>参数说明：</p><ul><li>key、value：键值对；</li><li>PX milliseconds：设置键的过期时间为 milliseconds 毫秒；</li><li>NX：只在键不存在时，才对键进行设置操作。SET key value NX 效果等同于 SETNX key value；</li><li>PX、expireTime：用于解决没有解锁导致的死锁问题。因为如果没有过期时间，万一程序员写的代码有 bug 导致没有解锁操作，则就出现了死锁，因此该参数起到了一个“兜底”的作用；</li></ul><p>Spring Data Redis 已经帮我们封装好了现成的方法，拿来开箱直接使用即可。代码如下：</p><h3 id="_1、加锁" tabindex="-1"><a class="header-anchor" href="#_1、加锁"><span>1、加锁</span></a></h3><div align="left"><img src="'+p+'" width="750px"></div><p>首次加锁，Redis 中 key 是空的，键值对关联成功后，调用结果返回 True，表示加锁成功。</p><p>为了防止一些特殊情况出现，导致锁没有正常释放，这里为 Key 设置了一个过期时间，作为一个兜底策略，超时锁会自动释放</p><h3 id="_2、释放锁" tabindex="-1"><a class="header-anchor" href="#_2、释放锁"><span>2、释放锁</span></a></h3><div align="left"><img src="'+r+'" width="600px"></div><p>删除key，表示释放分布式锁。</p><p>简单几行代码，就可以实现一个分布式锁，感觉也没什么复杂的。</p><p>根据二八原则，80% 的时间都花费在少数几件重要的事情上。我们做系统开发也是一样道理，功能编码可能只需要几天时间，但是优化其中的性能、稳定性、高可用 等可能要花上一周甚至更长时间。</p><p>那我们看看上面的方案有没有瑕疵呢？</p><p>加锁和解锁这种通用性操作一般都是以公共组件形式存在，比如封装成一个工具类方法，供上层业务直接调用，避免重复建设。</p><p>这就带来一个问题，如果一个新同学没有调用 lock() 方法，上来直接先调用了 unLock() 方法，此时会将别人的锁释放掉，引发数据安全问题。</p><p>为了解决这个问题，我们要求哪个线程加的锁，同样必须那个线程才能释放锁。</p><h2 id="三、安全解锁" tabindex="-1"><a class="header-anchor" href="#三、安全解锁"><span>三、安全解锁</span></a></h2><p>如何才能达到加锁和释放锁绑定到同一个线程呢？</p><p>这里提供了一个简单思路</p><ul><li>我们在加锁的时候，会将线程的 id 编号存到 Redis 缓存中，预埋了个线索</li><li>我们释放锁时，需再次传入线程 id，比较操作的 key 是否归属于这个线程 id</li><li>如果匹配成功，才能执行删除操作</li></ul><p>释放锁有多个操作，为了保证操作的原子性，这里采用 Lua 脚本</p><div align="left"><img src="'+o+'" width="450px"></div><p><strong>演示代码：</strong></p><div align="left"><img src="'+n+'" width="750px"></div><p>现在貌似<code>加锁</code> 和<code>释放锁 </code>基本能满足需求，但是一个方法内部调用逻辑通常是复杂的。</p><p>如果上层已经获得了锁，那后面的方法对同一个 key 将无法再次获得锁了，我们要考虑锁的可重入性。</p><h2 id="四、支持可重入性" tabindex="-1"><a class="header-anchor" href="#四、支持可重入性"><span>四、支持可重入性</span></a></h2><p>为了便于理解，画了个流程图，在第四步内部业务逻辑处理完后，会把锁释放了。</p><p>这时，回到最外层第六步，再释放锁时，已经没有锁可以释放了，虽然删除本身具有幂等性。</p><p>但这个期间，由于锁已经被内部方法早早的释放了，其他线程就可以重新拿到锁，从而导致数据安全问题。</p><div align="left"><img src="'+c+'" width="450px"></div><p>参考 <code>ReentrantLock</code> 锁的可重入性设计思路，在加锁、释放锁的方法中加入计数器</p><ul><li>首先，查询 key1 关联的值</li><li>如果为空，说明该线程能拿到锁，将 value 值关联到 key1 上</li><li>同时，定义了一个计数器 key2，将其关联的数值 加 1 ，初始为空，默认为 0</li><li>最后，将 key1、key2 设置过期时间</li></ul><h3 id="加锁-lua-脚本" tabindex="-1"><a class="header-anchor" href="#加锁-lua-脚本"><span>加锁 Lua 脚本</span></a></h3><div align="left"><img src="'+d+'" width="450px"></div><h3 id="释放锁-lua-脚本" tabindex="-1"><a class="header-anchor" href="#释放锁-lua-脚本"><span>释放锁 Lua 脚本</span></a></h3><p>释放锁时，除了比较 <code>线程标识</code> 来判断是否当前线程持有的锁外，还增加了一些逻辑</p><p>对锁计数器减一，当值变为0时，对分布式锁的 key 做清理动作</p><div align="left"><img src="'+h+'" width="450px"></div><p>结果描述：</p><blockquote><p>返回 1，表示解锁成功。返回 0，表示解锁失败，不是自己的锁</p></blockquote><h2 id="五、阻塞锁-非阻塞锁" tabindex="-1"><a class="header-anchor" href="#五、阻塞锁-非阻塞锁"><span>五、阻塞锁/非阻塞锁</span></a></h2><p>Number count = redisTemplate.execute(RedisScriptConfig.getReentrantScript(), keys, value, 30);</p><p>上面提供的都是<code>非阻塞锁</code> ，不管是否能获取锁，都会立即返回。</p><p>对于阻塞锁，我们可以参考 JUC 并发包的 Atomic 实现方式，采用<code>自旋锁</code></p><div align="left"><img src="'+l+'" width="750px"></div><h2 id="代码地址" tabindex="-1"><a class="header-anchor" href="#代码地址"><span>代码地址</span></a></h2><p><a href="https://github.com/aalansehaiyang/redis-limit-demo" target="_blank" rel="noopener noreferrer">https://github.com/aalansehaiyang/redis-limit-demo</a></p>',62)]))}const k=i(b,[["render",m]]),_=JSON.parse('{"path":"/posts/interview/arch/case/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"如何设计一个 Redis 分布式锁？","lang":"zh-CN","frontmatter":{"title":"如何设计一个 Redis 分布式锁？","description":"如何设计一个 Redis 分布式锁？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 多线程并发在我们做系统架构设计中经常遇到，例如：抽奖、秒杀、库存 等。 面对多个请求同时对一个共享资源 修改，如何保证数据安全，这里就需要引入 锁 来解决临界资源的访问安全。 JDK 中提供了 synchro...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/case/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"如何设计一个 Redis 分布式锁？"}],["meta",{"property":"og:description","content":"如何设计一个 Redis 分布式锁？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 多线程并发在我们做系统架构设计中经常遇到，例如：抽奖、秒杀、库存 等。 面对多个请求同时对一个共享资源 修改，如何保证数据安全，这里就需要引入 锁 来解决临界资源的访问安全。 JDK 中提供了 synchro..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何设计一个 Redis 分布式锁？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":5.36,"words":1609},"filePathRelative":"posts/interview/arch/case/Redis分布式锁.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>多线程并发在我们做系统架构设计中经常遇到，例如：抽奖、秒杀、库存 等。</p>\\n<p>面对多个请求同时对一个<code>共享资源</code> 修改，如何保证数据安全，这里就需要引入 <code>锁</code> 来解决临界资源的访问安全。</p>","autoDesc":true}');export{k as comp,_ as data};
