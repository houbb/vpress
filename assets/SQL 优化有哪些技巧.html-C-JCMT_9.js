import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as a}from"./app-NomDibRt.js";const l="/vpress/images/middleware/mysql/6-1.jpg",d="/vpress/images/middleware/mysql/6-2.jpg",p="/vpress/images/middleware/mysql/6-3.jpg",r="/vpress/images/middleware/mysql/6-11.jpg",t="/vpress/images/middleware/mysql/6-4.jpg",o="/vpress/images/middleware/mysql/6-5.jpg",c="/vpress/images/middleware/mysql/6-6.jpg",h="/vpress/images/middleware/mysql/6-7.jpg",b="/vpress/images/middleware/mysql/6-8.jpg",g="/vpress/images/middleware/mysql/6-9.jpg",m={};function u(v,e){return a(),s("div",null,e[0]||(e[0]=[n('<h1 id="sql-优化有哪些技巧" tabindex="-1"><a class="header-anchor" href="#sql-优化有哪些技巧"><span>SQL 优化有哪些技巧？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>MySQL 相信大家一定都不陌生，但是不陌生不一定会用！</p><p>会用不一定能用好！</p><div align="left"><img src="'+l+'" width="260px"></div><p>今天，老马就带大家复习一个高频面试考点，SQL 优化有哪些技巧？</p><p>当然这个还是非常有实用价值的，工作中你也一定用的上。如果应用得当，升职加薪，指日可待</p><h2 id="_1、创建索引" tabindex="-1"><a class="header-anchor" href="#_1、创建索引"><span>1、创建索引</span></a></h2><p>一定要记得创建索引，创建索引，创建索引</p><p>重要的事说三遍！</p><p>执行没有索引的 SQL 语句，肯定要走全表扫描，慢是肯定的。</p><p>这种查询毫无疑问是一个慢 SQL 查询。</p><p>那么问题来了，是不是要收集所有的 where 查询条件，然后针对所有的组合都创建索引呢？</p><blockquote><p>答案肯定是否定的。</p></blockquote><p>MySQL 为了提升数据查询速率，采用 B+ 树结构，通过<code>空间换时间</code> 设计思想。另外每次对表数据做更新操作时，都要调整对应的 <code>索引树</code> ，执行效率肯定会受影响。</p><p>本着<code>二八原则</code>，互联网请求<code>读多写少</code>的特点，我们一定要找到一个平衡点。</p><p>阿里巴巴的开发者手册建议，<strong>单表索引数量控制在5个以内，组合索引字段数不允许超过5个</strong></p><p><strong>其他建议：</strong></p><ul><li>禁止给表中的每一列都建立单独的索引</li><li>每个Innodb表必须有个主键</li><li>要注意组合索引的字段的顺序</li><li>优先考虑覆盖索引</li><li>避免使用外键约束</li></ul><h2 id="_2、避免索引失效" tabindex="-1"><a class="header-anchor" href="#_2、避免索引失效"><span>2、避免索引失效</span></a></h2><p>不要以为有了索引，就万事大吉。</p><p>殊不知，<code>索引失效</code> 也是慢查询的主要原因之一。</p><p><strong>常见的索引失效的场景有哪些？</strong></p><ul><li>以 % 开头的 LIKE 查询</li><li>创建了组合索引，但查询条件不满足 &#39;最左匹配原则&#39;。如： 创建索引 idx_type_status_uid（type,status,uid），但是使用 status 和 uid 作为查询条件。</li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</li><li>在索引列上的操作，函数 upper()等，or、！= （&lt;&gt;）,not in 等</li></ul><h2 id="_3、锁粒度" tabindex="-1"><a class="header-anchor" href="#_3、锁粒度"><span>3、锁粒度</span></a></h2><p>MySQL 的存储引擎分为两大类：MyISAM 和 InnoDB 。</p><p>MyISAM 支持表锁；InnoDB 支持行锁和表锁</p><p>更新操作时，为了保证表数据的准确性，通常会加锁，为了提高系统的高并发能力，我们通常建议采用 <code>行锁</code>，减少<code>锁冲突</code>、<code>锁等待</code> 的时间。所以，存储引擎通常会选择 <code>InnoDB</code></p><div align="left"><img src="'+d+'" width="260px"></div><p><strong>行锁可能会升级为表锁，有哪些场景呢？</strong></p><ul><li><p>如果一个表批量更新，大量使用行锁，可能导致其他事务长时间等待，严重影响事务的执行效率。此时，MySQL会将 <code>行锁</code> 升级为 <code>表锁</code></p></li><li><p>行锁是针对索引加的锁，如果 <code>条件索引失效</code>，那么 <code>行锁</code> 也会升级为 <code>表锁</code></p></li></ul><blockquote><p>注意：行锁将锁的粒度缩小了，进而提高了系统的并发能力。但是也有个弊端，可能会产生死锁，需要特别关注。</p></blockquote><h2 id="_4、分页查询优化" tabindex="-1"><a class="header-anchor" href="#_4、分页查询优化"><span>4、分页查询优化</span></a></h2><p>如果要开发一个列表展示页面并支持翻页时，我们通常会这样写 SQL</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select * from 表  limit #{start}, #{pageSize};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>随着翻页的深度加大， <code>start</code> 值越来越大，比如：limit 10000 ，10</p><p>看似只返回了 10 条数据，但数据库引擎需要查询 10010 条记录，然后将前面的 10000 条丢弃，最终只返回最后的 10 条记录，性能可想而知</p><p><strong>针对这个问题，我们通常有另一种解决方案：</strong></p><p>先定位到上一次分页的最大 id，然后对 id 做条件索引查询。由于数据库的索引采用 B+ 树结构，这样可以一步到位</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select * from 表 where id &gt; #{id}  limit  #{pageSize};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>任何事情，有利就有弊</p><p>这种翻页方式只支持 <code>上一页</code>、<code>下一页</code> ，不支持跨越式直梯翻页</p><div align="left"><img src="'+p+'" width="700px"></div><p>上图是淘宝的商品搜索列表，为了用户体验更好，采用的也是 <code>直梯式</code>翻页。</p><p>为了避免翻页过深，影响性能，产品交互上做了一些取舍，对总页数做了限制，最多支持 100 页。</p><p><strong>方案二：采用子查询</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select * from 表 where id &gt; ( select id from 表 order by id limit 10000 1) limit 20;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将原来的单 SQL 查询拆成两步：</p><ul><li>首先，查询出 一页数据中的最小 id</li><li>然后，通过 B+ 树，精确定位到 <code>最小id的索引树节点位置</code>，通过 <code>偏移量</code> 读取后面的 20条 数据</li></ul><p>阿里的规约手册也有对应描述：</p><div align="left"><img src="'+r+'" width="700px"></div><h2 id="_5、避免-select" tabindex="-1"><a class="header-anchor" href="#_5、避免-select"><span>5、避免 select *</span></a></h2><p><strong>反面案例：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select  * from 表 where buyer_id = #{buyer_id}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们知道，MySQL 创建表后，具体的行数据存储在主键索引（属于聚簇索引）的叶子节点。</p><p>二级索引属于非聚簇索引，其叶子节点存储的是<code>主键值</code></p><p><strong>select * 的查询过程：</strong></p><ul><li>先在 <code>buyer_id</code> 的二级索引 B+ 树，查出对应的 主键 id 列表</li><li>然后进行 <code>回表</code> 操作，在 主键索引中 查询 id 对应的行数据</li></ul><p>所以，我们需要罗列清楚必须的查询字段，且字段尽量在 <code>覆盖索引</code> 中，从而减少 <code>回表</code> 操作。</p><h2 id="_6、explain-分析-sql-执行计划" tabindex="-1"><a class="header-anchor" href="#_6、explain-分析-sql-执行计划"><span>6、EXPLAIN 分析 SQL 执行计划</span></a></h2><p>授人以鱼不如授人以渔</p><p>除了知晓常见的不规范 SQL 写法，在开发过程中，避免踩坑</p><p>我们还应知道，出现了慢 SQL 该如何排查、优化</p><div align="left"><img src="'+t+'" width="260px"></div><p>实验安排起来</p><p><strong>创建表</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE `user` (</span></span>\n<span class="line"><span>  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span></span>\n<span class="line"><span>  `income` bigint(20) NOT NULL COMMENT &#39;收入&#39;,</span></span>\n<span class="line"><span>  `expend` bigint(20) NOT NULL COMMENT &#39;支出&#39;,</span></span>\n<span class="line"><span>  PRIMARY KEY (`id`),</span></span>\n<span class="line"><span>  KEY `idx_income` (`income`)</span></span>\n<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#39;用户表&#39;;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>CREATE TABLE `biz_order` (</span></span>\n<span class="line"><span>  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;自增主键&#39;,</span></span>\n<span class="line"><span>  `user_id` bigint(20) NOT NULL COMMENT &#39;用户id&#39;,</span></span>\n<span class="line"><span>  `money` bigint(20) NOT NULL COMMENT &#39;金额&#39;,</span></span>\n<span class="line"><span>  PRIMARY KEY (`id`),</span></span>\n<span class="line"><span>  KEY `idx_user_id` (`user_id`)</span></span>\n<span class="line"><span>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&#39;订单表&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>插入记录：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>insert into user values(10,100,100);</span></span>\n<span class="line"><span>insert into user values(20,200,200);</span></span>\n<span class="line"><span>insert into user values(30,300,300);</span></span>\n<span class="line"><span>insert into user values(40,400,400);</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>insert into biz_order values(1,10,30);</span></span>\n<span class="line"><span>insert into biz_order values(2,10,40);</span></span>\n<span class="line"><span>insert into biz_order values(3,10,50);</span></span>\n<span class="line"><span>insert into biz_order values(4,20,10);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如下面的语句，我们看是否使用了索引，可以通过 <code>explain</code> 分析相应的执行计划</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>explain select * from user where  id&lt;20;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div align="left"><img src="'+o+`" width="750px"></div><p>接下来，我们来逐一来说明每个字段的含义</p><ul><li>id：每一次 select 查询都会生成一个 id，值越大，优先级越高，会被优先执行</li><li>select_type： 查询类型，SIMPLE（普通查询，即没有联合查询、子查询）、PRIMARY（主查询）、UNION（UNION 中后面的查询）、SUBQUERY（子查询）等</li><li>table：查询哪张表</li><li>partitions：分区，如果对应的表存在分区表，那么这里就会显示具体的分区信息</li><li>type：执行方式，是 SQL 优化中一个很重要的指标，结果值从好到差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>system/const：表中只有一行数据匹配，此时根据索引查询一次就能找到对应的数据</span></span>
<span class="line"><span>eq_ref：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件</span></span>
<span class="line"><span>ref：非唯一索引扫描，还可见于唯一索引最左原则匹配扫描</span></span>
<span class="line"><span>range：索引范围扫描，比如，&lt;，&gt;，between 等操作</span></span>
<span class="line"><span>index：索引全表扫描，此时遍历整个索引树</span></span>
<span class="line"><span>ALL：表示全表扫描，需要遍历全表来找到对应的行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>possible_keys：可能用到的索引</li><li>key：实际用到的索引</li><li>key_len：索引长度</li><li>ref：关联 id 等信息</li><li>rows：查找到记录所扫描的行数，SQL 优化重要指标，扫描的行数越少，性能越高</li><li>filtered：查找到所需记录占总扫描记录数的比例</li><li>Extra：额外的信息</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>explain select * from user u , biz_order b where u.id=b.user_id and u.id&lt;20;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div align="left"><img src="`+c+'" width="750px"></div><h2 id="_7、show-profile-分析-sql-执行性能" tabindex="-1"><a class="header-anchor" href="#_7、show-profile-分析-sql-执行性能"><span>7、Show Profile 分析 SQL 执行性能</span></a></h2><p>Show Profile 与 EXPLAIN 的区别是，前者主要是在外围分析；后者则是深入到 MySQL 内核，从执行线程的状态和时间来分析。</p><p>MySQL 是在 5.0.37 版本之后才支持 Show Profile ，<code>select @@have_profiling</code> 返回 <code>YES</code> 表示功能已开启。</p><div align="left"><img src="'+h+`" width="750px"></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; show profiles;</span></span>
<span class="line"><span>Empty set, 1 warning (0.00 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>显示为空，说明profiles功能是关闭的。</p><p>通过下面命令开启</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>mysql&gt; set profiling=1;</span></span>
<span class="line"><span>Query OK, 0 rows affected, 1 warning (0.00 sec)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div align="left"><img src="`+b+'" width="750px"></div><p>获取 <code>Query_ID</code> 之后，通过 <code>show profile for query ID</code> ，查看 SQL 语句在执行过程中线程的每个状态所消耗的时间</p><div align="left"><img src="'+g+'" width="550px"></div>',90)]))}const y=i(m,[["render",u]]),A=JSON.parse('{"path":"/posts/interview/middleware/mysql/SQL%20%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8A%80%E5%B7%A7.html","title":"SQL 优化有哪些技巧？","lang":"zh-CN","frontmatter":{"title":"SQL 优化有哪些技巧？","description":"SQL 优化有哪些技巧？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 MySQL 相信大家一定都不陌生，但是不陌生不一定会用！ 会用不一定能用好！ 今天，老马就带大家复习一个高频面试考点，SQL 优化有哪些技巧？ 当然这个还是非常有实用价值的，工作中你也一定用的上。如果应用得当，升职...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mysql/SQL%20%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8A%80%E5%B7%A7.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"SQL 优化有哪些技巧？"}],["meta",{"property":"og:description","content":"SQL 优化有哪些技巧？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 MySQL 相信大家一定都不陌生，但是不陌生不一定会用！ 会用不一定能用好！ 今天，老马就带大家复习一个高频面试考点，SQL 优化有哪些技巧？ 当然这个还是非常有实用价值的，工作中你也一定用的上。如果应用得当，升职..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SQL 优化有哪些技巧？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":7.59,"words":2277},"filePathRelative":"posts/interview/middleware/mysql/SQL 优化有哪些技巧.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>MySQL 相信大家一定都不陌生，但是不陌生不一定会用！</p>\\n<p>会用不一定能用好！</p>\\n<div align=\\"left\\">\\n    <img src=\\"/images/middleware/mysql/6-1.jpg\\" width=\\"260px\\">\\n</div>","autoDesc":true}');export{y as comp,A as data};
