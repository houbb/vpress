import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as o,o as p}from"./app-NomDibRt.js";const r="/vpress/images/middleware/redis/36-1.jpeg",s="/vpress/images/middleware/redis/36-4.jpeg",d="/vpress/images/middleware/redis/36-2.jpeg",a="/vpress/images/middleware/redis/36-3.jpeg",l="/vpress/images/middleware/redis/36-5.jpeg",n="/vpress/images/middleware/redis/36-6.jpeg",c="/vpress/images/middleware/redis/36-7.jpeg",h="/vpress/images/middleware/redis/36-8.jpeg",E={};function m(g,e){return p(),i("div",null,e[0]||(e[0]=[o('<h1 id="redis主节点的key已过期-但client访问从节点依然可以读到过期数据-为什么" tabindex="-1"><a class="header-anchor" href="#redis主节点的key已过期-但client访问从节点依然可以读到过期数据-为什么"><span>Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><hr><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>我们知道，大部分的业务场景都是读多写少，为了利用好这个特性，提升Redis集群系统的吞吐能力，通常会采用<code>主从架构</code>、<code>读写分离</code></p><div align="left"><img src="'+r+'" width="460px"></div><p>如上图所示：其中</p><ul><li>Master节点：负责业务的写操作</li><li>Slave节点：实时同步Master节点的数据，提供读能力</li></ul><blockquote><p>为了提高吞吐量，采用一主多从的架构，将业务的读压力分摊到多台服务器上</p></blockquote><p>上述方案，看似合理，但其实可能存在一定隐患！</p><div align="left"><img src="'+s+'" width="460px"></div><h2 id="一、拉取过期数据" tabindex="-1"><a class="header-anchor" href="#一、拉取过期数据"><span>一、拉取过期数据</span></a></h2><p>Redis性能高主要得益于纯内存操作，但内存存储介质的成本过高，所以数据的存储有一定的约束。</p><p>通常会设置<code>过期时间</code>，对于一些使用不是很频繁的数据，会定期删除，提高资源的利用率。</p><p><strong>删除过期数据，Redis提供了两种策略：</strong></p><h3 id="_1、惰性删除" tabindex="-1"><a class="header-anchor" href="#_1、惰性删除"><span>1、惰性删除</span></a></h3><p>也称被动删除，当数据过期后，并不会马上删除。而是等到有请求访问时，对数据检查，如果数据过期，则删除数据。</p><blockquote><p>优点：不需要单独启动额外的扫描线程，减少了CPU资源的损耗。</p></blockquote><blockquote><p>缺点：大量的过期数据滞留内存中，需要主动触发、检查、删除，否则会一直占用内存资源。</p></blockquote><h3 id="_2、定期删除" tabindex="-1"><a class="header-anchor" href="#_2、定期删除"><span>2、定期删除</span></a></h3><p>每隔一段时间，<code>默认100ms</code>，Redis会随机挑选一定数量的Key，检查是否过期，并将过期的数据删除。</p><p><strong>你可能会为问了，既然Redis有过期数据删除策略，那为什么还会拉取到已经过期的数据呢？</strong></p><div align="left"><img src="'+d+'" width="300px"></div><p>这要从<code>主从同步</code>讲起了，我们先来看张流程图</p><div align="left"><img src="'+a+'" width="560px"></div><p><strong>当客户端往主库写入数据后，并设置了过期时间，数据会以异步方式同步给从库。</strong></p><p>1、如果此时读主库，数据已经过期，主库的<code>惰性删除</code>会发挥作用，主动触发删除操作，客户端不会拿到已过期数据</p><p>2、但是如果读从库，则有可能拿到过期数据。原因有两个</p><p><strong>原因一：</strong></p><p>跟 Redis 的版本有关系，Redis 3.2 之前版本，读从库并不会判断数据是否过期，所以有可能返回过期数据。</p><p><strong>解决方案：</strong></p><p>升级Redis的版本，至少要3.2 以上版本，读从库，如果数据已经过期，则会过滤并返回空值。</p><blockquote><p>特别注意：<br> 此时同步过来的数据，虽然已经过期，但本着谁生产谁维护的原则，从库并不会主动删除同步的数据，需要依赖于主节点同步过来的key删除命令。</p></blockquote><p><strong>原因二：</strong></p><p>跟过期时间的设置方式有关系，我们一般采用 <code>EXPIRE 和 PEXPIRE</code>，表示从执行命令那个时刻开始，往后延长 ttl 时间。严重依赖于 <code>开始时间</code> 从什么时候算起。</p><ul><li>EXPIRE：单位为秒</li><li>PEXPIRE：单位为毫秒</li></ul><div align="left"><img src="'+l+'" width="560px"></div><p>如上图所示，简单描述下过程：</p><ul><li>主库在 t1 时刻写入一个带过期时间的数据，数据的有效期一直到 t3</li><li>由于网络原因、或者缓存服务器的执行效率，从库的命令并没有立即执行。一直等到了 t2 才开始执行，<br> 数据的有效期则会延后到 t5</li><li>如果，此时客户端访问从库，发现数据依然处于有效期内，可以正常使用</li></ul><p><strong>解决方案：</strong></p><p>可以采用Redis的另外两个命令，<code>EXPIREAT 和 PEXPIREAT</code>，相对简单，表示过期时间为一个具体的时间点。避免了对<code>开始时间</code>从什么时候算起的依赖。</p><ul><li>EXPIREAT：单位为秒</li><li>PEXPIREAT：单位为毫秒</li></ul><blockquote><p>特别注意：<br> EXPIREAT 和 PEXPIREAT 设置的是时间点，所以要求主从节点的时钟保持一致，需要与<code>NTP 时间服务器</code>保持时钟同步。</p></blockquote><div align="left"><img src="'+n+'" width="300px"></div><p>主从同步，除了<code>读从库</code>可能拉取到过期数据，还可能遇到数据一致性问题。</p><p>继续往下看</p><h2 id="二、主从数据不一致" tabindex="-1"><a class="header-anchor" href="#二、主从数据不一致"><span>二、主从数据不一致</span></a></h2><p>解释下，什么是主从数据不一致？ 指客户端从库中读取到的值与主库中读取的值不一致！</p><div align="left"><img src="'+c+'" width="560px"></div><p>如图所示：</p><ul><li>客户端写入主库，值为100</li><li>然后，主库将值100 同步给 从库</li><li>接着，客户端又访问主库，将值更新为 200</li><li>由于主从同步是异步进行的，有一定延迟，假如最新数据还没有同步到从库，那么从库读取的就不是最新值。</li></ul><p><strong>从库同步落后的原因主要有两个：</strong></p><p>1、主从服务器间的网络传输可能有延迟</p><p>2、从库已经收到主库的命令，由于是单线程执行，前面正在处理一些耗时的命令（如：pipeline批处理），无法及时同步执行。</p><p><strong>解决方案：</strong></p><p>1、主从服务器尽量部署在同一个机房，并保持服务器间的网络良好通畅</p><p>2、监控主从库间的同步进度，通过<code>info replication</code>命令 ，查看主库接收写命令的进度信息（master_repl_offset），从库的复制写命令的进度信息（slave_repl_offset）</p><div align="left"><img src="'+h+'" width="600px"></div><blockquote><p>master_repl_offset - slave_repl_offset， 得到从库与主库间的复制进度差值</p></blockquote><p>我们可以开发一个监控程序，定时拉取主从服务器的进度信息，计算进度差值。如果超过我们设置的阈值，则通知客户端断开从库的连接，全部访问主库，一定程度上减少数据不一致情况。</p><p>待同步进度跟上后，我们再恢复客户端与从节点的读操作。</p>',61)]))}const u=t(E,[["render",m]]),B=JSON.parse('{"path":"/posts/interview/middleware/redis/Redis%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9A%84Key%E5%B7%B2%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%BD%86Client%E8%AE%BF%E9%97%AE%E4%BB%8E%E8%8A%82%E7%82%B9%E4%BE%9D%E7%84%B6%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%88%B0%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE.html","title":"Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？","lang":"zh-CN","frontmatter":{"title":"Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？","description":"Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们知道，大部分的业务场景都是读多写少，为了利用好这个特性，提升Redis集群系统的吞吐能力，通常会采用主从架构、读写分离 如上图所示：其中 Mast...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/redis/Redis%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9A%84Key%E5%B7%B2%E8%BF%87%E6%9C%9F%EF%BC%8C%E4%BD%86Client%E8%AE%BF%E9%97%AE%E4%BB%8E%E8%8A%82%E7%82%B9%E4%BE%9D%E7%84%B6%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%88%B0%E8%BF%87%E6%9C%9F%E6%95%B0%E6%8D%AE.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？"}],["meta",{"property":"og:description","content":"Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们知道，大部分的业务场景都是读多写少，为了利用好这个特性，提升Redis集群系统的吞吐能力，通常会采用主从架构、读写分离 如上图所示：其中 Mast..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据， 为什么？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":5.34,"words":1601},"filePathRelative":"posts/interview/middleware/redis/Redis主节点的Key已过期，但Client访问从节点依然可以读到过期数据.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<hr>\\n<h2>简介</h2>\\n<p>我们知道，大部分的业务场景都是读多写少，为了利用好这个特性，提升Redis集群系统的吞吐能力，通常会采用<code>主从架构</code>、<code>读写分离</code></p>","autoDesc":true}');export{u as comp,B as data};
