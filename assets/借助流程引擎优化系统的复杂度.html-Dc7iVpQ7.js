import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as n}from"./app-NomDibRt.js";const t="/vpress/images/arch/case/3-1.png",l="/vpress/images/arch/case/3-2.png",r="/vpress/images/arch/case/3-3.png",p="/vpress/images/arch/case/3-4.png",o="/vpress/images/arch/case/3-5.png",c="/vpress/images/arch/case/3-6.png",d="/vpress/images/arch/case/3-7.png",h="/vpress/images/arch/case/3-8.png",g="/vpress/images/arch/case/3-9.png",b="/vpress/images/arch/case/3-10.png",m="/vpress/images/arch/case/3-11.png",v={};function u(k,s){return n(),i("div",null,s[0]||(s[0]=[a('<h1 id="借助流程引擎降低系统的复杂度" tabindex="-1"><a class="header-anchor" href="#借助流程引擎降低系统的复杂度"><span>借助流程引擎降低系统的复杂度！</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>作为软件架构师，当面对复杂的业务逻辑，我们常用的解决方案就是拆分</p><ol><li>将一个大的业务域拆分为若干子域</li><li>将相似业务逻辑抽象成若干组件，并结合 23 种软件设计模式，提升系统扩展性</li></ol><p>以流量网关为例：</p><div align="left"><img src="'+t+'" width="700px"></div><p>我们会定义 <code>Filter</code> 接口，子类通过实现 <code>filter()</code> 方法来满足自己的业务逻辑，如：<code>限流逻辑</code> 、<code>鉴权逻辑</code> 等，如果某些业务流程不需要执行该 <code>Filter</code> 组件，我们可以在 <code>isSkip</code> 方法里定义跳出逻辑，直接跳过该组件，继续执行下一个组件。</p><p>最后我们定义了这么多的 Filter 组件，通过 Spring 框架扫描优先级注解，完成了组件链的串联。</p><p>当然这个编排比较单一，不够灵活。无法实现一些<code>串行</code> 、<code>并行</code> 的自由组合。</p><div align="left"><img src="'+l+`" width="450px"></div><p>比如，我们面对上图这样的业务流程该如何应对？是自己借助 JUC 并发包以及各种 if else 定制化实现流程控制吗？</p><p>另外，随着业务后续迭代，这些任务间的关系还会发生变化，每次都去改动代码，违反软件的<code>开闭原则</code> ，很容易发生线上故障。</p><p>**🚀 给大家推荐一款轻量级的流程引擎 **</p><h2 id="liteflow" tabindex="-1"><a class="header-anchor" href="#liteflow"><span>LiteFlow</span></a></h2><p>LiteFlow 是一款国产开源的，具有轻量，快速，稳定可编排的组件式规则引擎，帮助我们拆解实现各种复杂的业务逻辑，开箱即用，上手容易。</p><h2 id="主要特性" tabindex="-1"><a class="header-anchor" href="#主要特性"><span>主要特性</span></a></h2><ol><li><strong>组件定义统一：</strong> 所有的逻辑都是组件，为所有的逻辑提供统一化的组件实现方式，小身材，大能量。</li><li><strong>规则轻量：</strong> 基于规则文件来编排流程，学习规则入门只需要5分钟，一看既懂。</li><li><strong>规则多样化：</strong> 规则支持xml、json、yml三种规则文件写法方式，喜欢哪种用哪个。</li><li><strong>任意编排：</strong> 同步异步混编，再复杂的逻辑过程，利用LiteFlow的规则，都是很容易做到的，看规则文件就能知道逻辑是如何运转的。</li><li><strong>规则能从任意地方加载：</strong> 框架中提供本地文件配置源和zk配置源的实现，也提供了扩展接口，您可以把规则存储在任何地方。</li><li><strong>优雅热刷新机制：</strong> 规则变化，无需重启您的应用，即时改变应用的规则。高并发下不会因为刷新规则导致正在执行的规则有任何错乱。</li><li><strong>支持广泛：</strong> 不管你的项目是不是基于Springboot，Spring还是任何其他java框架构建，LiteFlow都能游刃有余。</li><li><strong>JDK支持：</strong> 从JDK8到JDK17，统统支持。无需担心JDK版本。</li><li><strong>脚本语言支持：</strong> 可以定义脚本语言节点，支持QLExpress和Groovy两种脚本。未来还会支持更多的脚本语言。</li><li><strong>规则嵌套支持：</strong> 只要你想的出，你可以利用简单的表达式完成多重嵌套的复杂逻辑编排。</li><li><strong>组件重试支持：</strong> 组件可以支持重试，每个组件均可自定义重试配置和指定异常。</li><li><strong>上下文隔离机制：</strong> 可靠的上下文隔离机制，你无需担心高并发情况下的数据串流。</li><li><strong>声明式组件支持：</strong> 你可以让你的任意类秒变组件。</li><li><strong>详细的步骤信息：</strong> 你的链路如何执行的，每个组件耗时多少，报了什么错，一目了然。</li><li><strong>稳定可靠：</strong> 历时2年多的迭代，在各大公司的核心系统上稳定运行。</li><li><strong>性能卓越：</strong> 框架本身几乎不消耗额外性能，性能取决你的组件执行效率。</li><li><strong>自带简单监控：</strong> 框架内自带一个命令行的监控，能够知道每个组件的运行耗时排行。</li></ol><p>LiteFlow 设计了非常强大的规则表达式，一切复杂的流程在 LiteFlow 表达式的加持下，都异常丝滑简便。</p><p>我们来一起看下 EL 规则的写法</p><h2 id="liteflow-规则语法" tabindex="-1"><a class="header-anchor" href="#liteflow-规则语法"><span>LiteFlow 规则语法</span></a></h2><h3 id="_1、串行编排" tabindex="-1"><a class="header-anchor" href="#_1、串行编排"><span>1、串行编排</span></a></h3><p>依次执行 a、b、c、d四个组件，用 THEN 关键字</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;chain1&quot;&gt;</span></span>
<span class="line"><span> THEN(a, b, c, d);</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、并行编排" tabindex="-1"><a class="header-anchor" href="#_2、并行编排"><span>2、并行编排</span></a></h3><p>并行执行a、b、c三个组件，用<code>WHEN</code> 关键字</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;chain1&quot;&gt;</span></span>
<span class="line"><span> WHEN(a, b, c);</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、选择编排" tabindex="-1"><a class="header-anchor" href="#_3、选择编排"><span>3、选择编排</span></a></h3><p>根据组件 a 的运行结果，选择执行 b、c、d 中的一个，用 <code>SWITCH</code> 关键字</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;chain1&quot;&gt;</span></span>
<span class="line"><span> SWITCH(a).to(b, c, d);</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、条件编排" tabindex="-1"><a class="header-anchor" href="#_4、条件编排"><span>4、条件编排</span></a></h3><p>条件编排就是变成语言中的 if else，使用 IF 关键字</p><p>其中 x 为条件节点，为真的情况下，执行链路就为x-&gt;a-&gt;c，为假链路就为x-&gt;b-&gt;c</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;chain1&quot;&gt;</span></span>
<span class="line"><span> THEN(</span></span>
<span class="line"><span> IF(x, a, b),</span></span>
<span class="line"><span> c</span></span>
<span class="line"><span> );</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如，我们要实现这样一个复杂的流程</p><div align="left"><img src="`+r+`" width="600px"></div><p>对应的 EL 表达式为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;chain1&quot;&gt;</span></span>
<span class="line"><span> IF(x1, a).ELIF(x2, b).ELIF(x3, c).ELIF(x4, d).ELSE(THEN(m, n));</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、子流程" tabindex="-1"><a class="header-anchor" href="#_5、子流程"><span>5、子流程</span></a></h3><p>当遇到一些复杂的业务，表达式嵌套多层，很不直观，我们可以先定义子流程，然后在主流程中引用。这样逻辑会比较清晰</p><p>定义子流程 <code>sub_chain</code> ，串行执行 a、b 两个组件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;sub_chain&quot;&gt;</span></span>
<span class="line"><span> 	THEN(a,b);</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在主流程中引入之前定义的子流程 sub_chain</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;chain name=&quot;mainChain&quot;&gt;</span></span>
<span class="line"><span> WHEN(</span></span>
<span class="line"><span> 	sub_chain,</span></span>
<span class="line"><span> c,d</span></span>
<span class="line"><span> );</span></span>
<span class="line"><span>&lt;/chain&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="实战案例" tabindex="-1"><a class="header-anchor" href="#实战案例"><span>实战案例</span></a></h2><h3 id="_1、需求描述" tabindex="-1"><a class="header-anchor" href="#_1、需求描述"><span>1、需求描述</span></a></h3><p>看完介绍是不是很手痒，接下来我们就以一个电商的 订单价格计算 为例子，讲解下 LiteFlow 如何使用</p><p>首先，我们看下订单价格计算接口 都涉及哪些业务逻辑，为了快速切入，画了个流程图便于大家理解</p><p>毕竟，一图胜千言哈</p><div align="left"><img src="`+p+'" width="500px"></div><h3 id="_2、项目代码实现" tabindex="-1"><a class="header-anchor" href="#_2、项目代码实现"><span>2、项目代码实现</span></a></h3><p>以 Spring Boot 应用为例，首先在 pom.xml 文件添加下面的依赖</p><div align="left"><img src="'+o+'" width="400px"></div><p>修改 application.yml 配置文件，添加 LiteFlow 的规则文件路径</p><div align="left"><img src="'+c+'" width="400px"></div><p>定义组件，继承 NodeComponent 类 ，并重写 process() 方法，里面实现自己负责的业务逻辑，比如：促销满减计算、会员折扣计算、运费计算等</p><p>通过重写 isAccess() 方法来决定是否执行该组件</p><p>MemberDiscountCmp 负责会员折扣计算，根据 memberCode 查询会员等级，并获取对应的会员折扣，然后计算订单可以减免多少优惠</p><div align="left"><img src="'+d+'" width="700px"></div><p>PostageCondCmp 组件比较特殊，根据 是否境外购 选择对应的运费计算组件，继承了 NodeSwitchComponent ，并实现了 processSwitch() 方法</p><div align="left"><img src="'+h+'" width="600px"></div><p>其他业务组件 基本类似，就不一一介绍了，感兴趣的同学可以自己看下代码</p><div align="left"><img src="'+g+'" width="300px"></div><p>所有组件实例无缝支持 Spring 框架，通过<code>@Component </code>注解标识，所有的Bean实例全部交由 Spring 容器统一管理</p><p>定义好组件后，接下来就要编写 EL 规则表达式，将所有的流程关联起来</p><div align="left"><img src="'+b+'" width="600px"></div><p>最后，启动 Spring Boot 工程，访问地址：<a href="http://localhost:8580/" target="_blank" rel="noopener noreferrer">http://localhost:8580/</a></p><div align="left"><img src="'+m+'" width="600px"></div><h2 id="代码地址" tabindex="-1"><a class="header-anchor" href="#代码地址"><span>代码地址</span></a></h2><blockquote><p><a href="https://gitee.com/aalansehaiyang/liteflow-example" target="_blank" rel="noopener noreferrer">https://gitee.com/aalansehaiyang/liteflow-example</a></p></blockquote>',69)]))}const x=e(v,[["render",u]]),E=JSON.parse('{"path":"/posts/interview/arch/case/%E5%80%9F%E5%8A%A9%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6.html","title":"借助流程引擎降低系统的复杂度！","lang":"zh-CN","frontmatter":{"title":"借助流程引擎降低系统的复杂度！","description":"借助流程引擎降低系统的复杂度！ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 作为软件架构师，当面对复杂的业务逻辑，我们常用的解决方案就是拆分 将一个大的业务域拆分为若干子域 将相似业务逻辑抽象成若干组件，并结合 23 种软件设计模式，提升系统扩展性 以流量网关为例： 我们会定义 Filte...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/case/%E5%80%9F%E5%8A%A9%E6%B5%81%E7%A8%8B%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"借助流程引擎降低系统的复杂度！"}],["meta",{"property":"og:description","content":"借助流程引擎降低系统的复杂度！ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 作为软件架构师，当面对复杂的业务逻辑，我们常用的解决方案就是拆分 将一个大的业务域拆分为若干子域 将相似业务逻辑抽象成若干组件，并结合 23 种软件设计模式，提升系统扩展性 以流量网关为例： 我们会定义 Filte..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"借助流程引擎降低系统的复杂度！\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":6.49,"words":1946},"filePathRelative":"posts/interview/arch/case/借助流程引擎优化系统的复杂度.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>作为软件架构师，当面对复杂的业务逻辑，我们常用的解决方案就是拆分</p>\\n<ol>\\n<li>将一个大的业务域拆分为若干子域</li>\\n<li>将相似业务逻辑抽象成若干组件，并结合 23 种软件设计模式，提升系统扩展性</li>\\n</ol>","autoDesc":true}');export{x as comp,E as data};
