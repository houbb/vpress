import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a,o as i}from"./app-NomDibRt.js";const p="/vpress/images/arch/system/7-5.jpg",l="/vpress/images/arch/system/7-1.jpg",t="/vpress/images/arch/system/7-2.jpg",r="/vpress/images/arch/system/7-3.jpg",o={};function c(d,n){return i(),e("div",null,n[0]||(n[0]=[a('<h1 id="openresty-实现限流" tabindex="-1"><a class="header-anchor" href="#openresty-实现限流"><span>OpenResty 实现限流</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>目前限流的解决方案有很多，从分布式角度来看，限流可分为分布式限流（比如基于Sentinel或者 Redis的集群限流）和单机限流。</p><p>从算法实现角度来看，限流算法可分为<code>计数器算法</code>、<code>滑动时间窗口算法</code>、<code>漏桶算法</code>、<code>令牌桶算法</code></p><p><code>本文主要介绍如何在Nginx中增加流控功能，原因是考虑到nginx的广泛使用且基于流量的入口位置，越早拦截对后面系统的压力越小。</code></p><p>首先，我们先来了解下nginx，它是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><p><strong>Nginx可以做的事情很多，归纳起来主要有四块：</strong></p><p>1、反向代理</p><blockquote><p>接收Internet上的请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端</p></blockquote><p>2、负载均衡</p><blockquote><p>将大量的用户请求按照一定的负载策略分摊转发给内部的服务器。负载均衡策略有：轮询（默认）、weight、ip_hash、fair（第三方）、url_hash（第三方）</p></blockquote><p>3、HTTP服务器</p><blockquote><p>Nginx本身是一个静态资源的服务器，对静态资源缓存，提升性能。也可以实行动静分离，将动态请求转发给后台服务器。</p></blockquote><p>4、正向代理</p><blockquote><p>为了安全限制，有些内部服务器不允许直接访问外网，需要将请求转发到代理机，再由代理机访问internet。</p></blockquote><p><strong>那么，Nginx 如何做到高并发下的高效处理？</strong></p><p><code>现在的软件系统一般采用微服务架构，跨服务器请求产生了大量的网络IO，而IO等待严重影响系统吞吐量</code></p><p>Nginx采用异步事件驱动的方法来处理请求，Linux的epoll模型基于事件驱动机制，它可以监控多个事件是否准备就绪，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。官方测试结果，单台能够支持五万个并行连接。</p><p><code>Nginx采用模块化设计，扩展性好，但由于采用C语言，涉及大量的通信协议，开发环境复杂，门槛较高。有没有一种方式，通过简单的脚本语言就可以实现各种定制化功能，并能方便的集成到 Nginx中，OpenResty 是个不错选择，接下来，我们来了解下这个框架</code></p><h2 id="首先-了解下openresty" tabindex="-1"><a class="header-anchor" href="#首先-了解下openresty"><span>首先，了解下OpenResty</span></a></h2><p>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 服务器，其内部集成了大量 Lua 库、第三方模块以及大多数的依赖项。方便搭建支持高并发、高扩展性的动态 Web 服务和网关。</p><p>包含 Nginx、ngx_lua、LuaJIT 2.0/2.1 (或者可选的标准 Lua 5.1解释器)，还包含很多强劲、好用的 Nginx 模块。</p><blockquote><p>OpenResty 使用 Lua 编程语言对 Nginx 核心以及各种 Nginx C 模块进行脚本编程，可以处理一万以上并发请求。选择OpenResty，既拥有脚本语言的开发效率，以及 Nginx 高并发优势。</p></blockquote><p>OpenResty 现在是全球排名第三的 Web 服务器，由于将Nginx扩展成动态服务器，发展势头很猛。我们经常用到的 12306 的余票查询功能，或者是京东的商品详情页，这些高流量的背后，其实都是 OpenResty 在默默地提供服务。OpenResty 最擅长的是部署在流量入口处，处理各种高并发流量。</p><div align="left"><img src="'+p+'" width="650px"></div><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h2><ul><li>在请求真正到达下游服务之前，Lua 可以随心所欲的做复杂访问控制和安全检测</li><li>从外部存储服务（比如 redis, memcached, mysql, postgresql）中获取后端信息，并用这些信息来实时选择哪一个后端来完成业务访问</li><li>在内容 handler 中随意编写复杂的 web 应用，使用同步非阻塞的方式，访问后端数据库和其他存储</li><li>在 rewrite 阶段，通过 Lua 完成非常复杂的 URL dispatch</li><li>用 Lua 可以为 Nginx 子请求和任意 location，实现高级缓存机制</li></ul><blockquote><p>Nginx采用原生C语言开发的，通过<code>nginx-lua-module</code> 借助nginx开放的api，实现 Nginx 的各种功能自由拼接、业务定制化。Lua语言，大大降低了开发门槛。</p></blockquote><h2 id="如何二次开发" tabindex="-1"><a class="header-anchor" href="#如何二次开发"><span>如何二次开发</span></a></h2><p>我们编写的Lua脚本代码均包含在指令函数中，指令函数有严格的执行顺序。当接收请求时，通过指令函数对 <code>request </code> 、 <code>response</code>做二次干预处理，从而实现个性化业务。</p><p><strong>指令函数的执行顺序：</strong></p><div align="left"><img src="'+l+`" width="650px"></div><p>函数功能说明：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>set_by_lua，用于设置变量</span></span>
<span class="line"><span>rewrite_by_lua，用于转发、重定向等</span></span>
<span class="line"><span>access_by_lua，用于准入、权限等</span></span>
<span class="line"><span>content_by_lua，用于生成返回内容</span></span>
<span class="line"><span>header_filter_by_lua，用于响应头过滤处理</span></span>
<span class="line"><span>body_filter_by_lua，用于响应体过滤处理</span></span>
<span class="line"><span>log_by_lua，用于日志记录</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：OpenResty 的 API 有范围限制，每一个 API 都有一个与之对应的使用阶段列表，如果你超范围使用就会报错。</p></blockquote><h2 id="限流实战" tabindex="-1"><a class="header-anchor" href="#限流实战"><span>限流实战</span></a></h2><p>OpenResty 官方提供了封装好的 lua函数，方便我们开箱即用。支持一下几个场景：</p><ul><li>根据ip限制并发连接数</li><li>限制时间窗口的请求数，如：限制 ip 每分钟只能调用 100 次 /order 接口，（允许在时间段开始的时候一次性放过100个请求）</li><li>平滑限制接口请求数，如：限制 ip 每分钟只能调用 120 次 /order 接口（平滑处理请求，即每秒放过2个请求）</li><li>漏桶算法限流，如：限制 ip 每分钟只能调用 120 次 /order 接口（平滑处理请求，即每秒放过2个请求），超过的部分进入桶中等待，（桶容量为60），如果桶也满了，则进行限流</li></ul><h3 id="lua脚本" tabindex="-1"><a class="header-anchor" href="#lua脚本"><span>Lua脚本</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span> server {</span></span>
<span class="line"><span>        listen       80;</span></span>
<span class="line"><span>        server_name  localhost;</span></span>
<span class="line"><span>        charset utf-8;</span></span>
<span class="line"><span>        #access_log  logs/host.access.log  main;</span></span>
<span class="line"><span> </span></span>
<span class="line"><span>        # 限流示例</span></span>
<span class="line"><span>        location /order/limit {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            default_type &#39;text/html&#39;;</span></span>
<span class="line"><span>            access_by_lua_block {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                -- 导入模块</span></span>
<span class="line"><span>                local limit_count = require &quot;resty.limit.count&quot;</span></span>
<span class="line"><span>         </span></span>
<span class="line"><span>                -- 限流规则: 每分钟3次</span></span>
<span class="line"><span>                local lim, err = limit_count.new(&quot;my_limit_count_store&quot;, 3, 60)</span></span>
<span class="line"><span>                if not lim then</span></span>
<span class="line"><span>                    ngx.log(ngx.ERR, &quot;failed to instantiate a resty.limit.count object: &quot;, err)</span></span>
<span class="line"><span>                    return ngx.exit(500)</span></span>
<span class="line"><span>                end</span></span>
<span class="line"><span>         </span></span>
<span class="line"><span>                local key = ngx.var.binary_remote_addr</span></span>
<span class="line"><span>                local delay, err = lim:incoming(key, true)</span></span>
<span class="line"><span>                -- 如果请求数在限制范围内，则当前请求被处理的延迟（这种场景下始终为0，因为要么被处理要么被拒绝）和将被处理的请求的剩余数</span></span>
<span class="line"><span>                 ngx.log(ngx.ERR,&quot;delay: &quot;,delay,&quot; err: &quot;,err)</span></span>
<span class="line"><span>                if not delay then</span></span>
<span class="line"><span>                    if err == &quot;rejected&quot; then</span></span>
<span class="line"><span>                        ngx.say(&quot;访问太频繁了..&quot;,&quot;delay: &quot;,delay,&quot; , err: &quot;,err)</span></span>
<span class="line"><span>                        -- return ngx.exit(503)</span></span>
<span class="line"><span>                    end</span></span>
<span class="line"><span>         </span></span>
<span class="line"><span>                    ngx.log(ngx.ERR, &quot;被限流啦...... &quot;, err)</span></span>
<span class="line"><span>                    return ngx.exit(500)</span></span>
<span class="line"><span>                end</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                ngx.say(&quot;success&quot;)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>         </span></span>
<span class="line"><span>           </span></span>
<span class="line"><span>        }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>场景测试：</strong></p><p>流控设置规则，每分钟限制访问3次</p><p><strong>正常请求：</strong></p><div align="left"><img src="`+t+'" width="450px"></div><p><strong>请求过多，触发流控：</strong></p><div align="left"><img src="'+r+'" width="450px"></div>',46)]))}const m=s(o,[["render",c]]),h=JSON.parse('{"path":"/posts/interview/arch/system/OpenResty%20%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81.html","title":"OpenResty 实现限流","lang":"zh-CN","frontmatter":{"title":"OpenResty 实现限流","description":"OpenResty 实现限流 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 目前限流的解决方案有很多，从分布式角度来看，限流可分为分布式限流（比如基于Sentinel或者 Redis的集群限流）和单机限流。 从算法实现角度来看，限流算法可分为计数器算法、滑动时间窗口算法、漏桶算法、令牌桶算法...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/system/OpenResty%20%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"OpenResty 实现限流"}],["meta",{"property":"og:description","content":"OpenResty 实现限流 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 目前限流的解决方案有很多，从分布式角度来看，限流可分为分布式限流（比如基于Sentinel或者 Redis的集群限流）和单机限流。 从算法实现角度来看，限流算法可分为计数器算法、滑动时间窗口算法、漏桶算法、令牌桶算法..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"OpenResty 实现限流\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":6.02,"words":1807},"filePathRelative":"posts/interview/arch/system/OpenResty 实现限流.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>目前限流的解决方案有很多，从分布式角度来看，限流可分为分布式限流（比如基于Sentinel或者 Redis的集群限流）和单机限流。</p>\\n<p>从算法实现角度来看，限流算法可分为<code>计数器算法</code>、<code>滑动时间窗口算法</code>、<code>漏桶算法</code>、<code>令牌桶算法</code></p>","autoDesc":true}');export{m as comp,h as data};
