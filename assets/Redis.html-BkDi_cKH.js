import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as e,o as a}from"./app-NomDibRt.js";const l="/vpress/images/spring/springboot/3-2.jpg",p="/vpress/images/spring/springboot/3-3.jpg",r="/vpress/images/spring/springboot/3-1.jpg",t={};function d(c,s){return a(),i("div",null,s[0]||(s[0]=[e('<h1 id="开箱即用-一键集成-redis-缓存" tabindex="-1"><a class="header-anchor" href="#开箱即用-一键集成-redis-缓存"><span>开箱即用，一键集成 Redis 缓存</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>Redis 是一个开源、高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的 Web 应用程序。支持更丰富的数据结构，例如 String、List、hash、 set、 zset 等，同时支持数据持久化。</p><p>除此之外，Redis 还提供一些类数据库的特性，比如事务，HA，主从备份。可以说 Redis 兼具了缓存系统和数据库的一些特性。</p><p><strong>Redis特性</strong></p><ul><li>高并发读写</li><li>持久化</li><li>丰富的数据类型</li><li>单进程单线程模型</li><li>数据自动过期</li><li>发布订阅</li><li>分布式</li><li>支持lua脚本</li></ul><blockquote><p>目前在从阿里巴巴、美团、百度、拼多多、快手等一线大厂到五六线小厂中广泛使用，对系统的高并发能力贡献极大，深受好评，开源社区非常活跃。</p></blockquote><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><p>1、String</p><p>二进制的字符串，最简单的k-v存储，类似于memcached的存储结构，它不仅能够存储字符串、还能存储图片、视频等多种类型， 最大长度<strong>512M</strong>。支持丰富的操作命令，如：</p><ul><li>GET/MGET</li><li>SET/SETEX/MSET/MSETNX</li><li>INCR/DECR</li><li>GETSET</li><li>DEL</li></ul><p>2、Hash</p><p>采用主子key存储信息，由field和关联的value组成Map。比如计数器，key表示帖子id，field表示点赞数、评论数、转发数等，value则表示计数值。常用命令：</p><ul><li>HGET/HMGET/HGETALL</li><li>HSET/HMSET/HSETNX</li><li>HEXISTS/HLEN</li><li>HKEYS/HDEL</li><li>HVALS</li></ul><p>3、List</p><p>该类型是一个有序的元素集合，基于双向链表实现。比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。常用命令：</p><ul><li>LPUSH/LPUSHX/LPOP/RPUSH/RPUSHX/RPOP/LINSERT/LSET</li><li>LINDEX/LRANGE</li><li>LLEN/LTRIM</li></ul><p>4、Set</p><p>Set类型是一种无顺序集合。它和List类型最大的区别是：集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。底层是通过哈希表实现的。常用命令：</p><ul><li>SADD/SPOP/SMOVE/SCARD</li><li>SINTER/SDIFF/SDIFFSTORE/SUNION</li></ul><p>5、Sorted Set</p><p>是set的增强版本，有序集合类型，每个元素都会关联一个double类型的分数权值，通过这个权值来为集合中的成员进行从小到大的排序。与Set类型一样，其底层也是通过哈希表实现的。常用命令：</p><ul><li>ZADD/ZPOP/ZMOVE/ZCARD/ZCOUNT</li><li>ZINTER/ZDIFF/ZDIFFSTORE/ZUNION</li></ul><h2 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景"><span>适用场景</span></a></h2><p>1、高性能缓存。缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以Redis用在缓存的场合非常多。</p><p>作为缓存使用时，一般有两种方式保存数据：</p><ul><li>读取前，先去读Redis。如果没有数据，读取数据库，然后将数据预热到Redis。</li><li>写入时，先更新数据库，然后再写入Redis。</li></ul><p>2、丰富的数据类型，满足多样化业务需求。</p><p>3、分布式锁</p><p>在很多互联网公司中都使用了分布式技术，分布式技术带来的挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的<code>set nx</code>功能来编写分布式锁，如果设置返回1说明获取锁成功，否则获取锁失败。</p><p>4、消息队列</p><p>Redis 中 list 的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过 lpush 将消息放入 list，消费者便可以通过 rpop 取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择 sorted set。而 pub/sub 功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis 拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。</p><p>5、其他场景，如：秒杀、限流、计数器、排行榜、实时系统、共享session等</p><h2 id="单线程的redis为什么快" tabindex="-1"><a class="header-anchor" href="#单线程的redis为什么快"><span>单线程的Redis为什么快</span></a></h2><ul><li>纯内存操作</li><li>单线程操作，避免了频繁的上下文切换</li><li>合理高效的数据结构</li><li>采用了非阻塞I/O多路复用机制（有一个文件描述符同时监听多个文件描述符是否有数据到来）</li></ul><h2 id="如何实现键值对的快速访问" tabindex="-1"><a class="header-anchor" href="#如何实现键值对的快速访问"><span>如何实现键值对的快速访问</span></a></h2><p>Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。每个哈希桶中保存了<strong>键值对</strong>数据。</p><p>当然哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。</p><div align="left"><img src="'+l+'" width="800px"></div><p>哈希表的最大优势就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。我们只需要计算<code>key</code>的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p><p>hash值并不是唯一的，当面对海量数据存储，计算时可能会存在<strong>哈希冲突</strong>，导致两个entry落在同一个哈希桶中。解决方式也比较简单，引入链式哈希。同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</p><div align="left"><img src="'+p+`" width="800px"></div><h2 id="项目实战" tabindex="-1"><a class="header-anchor" href="#项目实战"><span>项目实战</span></a></h2><p>在pom.xml 中引入Spring Boot 官方提供的 starter组件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>&lt;dependency&gt;</span></span>
<span class="line"><span>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span>
<span class="line"><span>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span></span>
<span class="line"><span>&lt;/dependency&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>spring-boot-starter-data-redis</code> 依赖于 <code>spring-data-redis</code> 和 <code>lettuce </code> 。</p><blockquote><p>Spring Boot 1.X 版本默认使用的是 Jedis 客户端。2.X 版本替换成 Lettuce 客户端，如果习惯使用 Jedis 的话，可以从 spring-boot-starter-data-redis 中排除 Lettuce 并引入 Jedis。</p></blockquote><p>Lettuce 是一个可伸缩线程安全的 Redis 客户端，多个线程可以共享同一个 RedisConnection，它利用优秀 netty NIO 框架来高效地管理多个连接。</p><p><code>application.yaml</code> 配置redis的地址信息以及lettuce 连接池参数</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>spring:</span></span>
<span class="line"><span>  redis:</span></span>
<span class="line"><span>    host: 127.0.0.1</span></span>
<span class="line"><span>    port: 6379</span></span>
<span class="line"><span>    #    password: abEvH46*YsH&amp;S25d89</span></span>
<span class="line"><span>    lettuce:</span></span>
<span class="line"><span>      pool:</span></span>
<span class="line"><span>        maxIdle: 1000  # 连接池中的最大空闲连接</span></span>
<span class="line"><span>        minIdle: 2  # 连接池中的最小空闲连接</span></span>
<span class="line"><span>        maxWait: 10  # 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span></span>
<span class="line"><span>        maxActive: 1000 # 连接池最大连接数（使用负值表示没有限制）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化 redis的 <code>RedisTemplate </code> 模板bean实例</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Configuration</span></span>
<span class="line"><span>public class RedisConfig {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Bean</span></span>
<span class="line"><span>    RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) {</span></span>
<span class="line"><span>        final StringRedisTemplate template = new StringRedisTemplate();</span></span>
<span class="line"><span>        template.setConnectionFactory(factory);</span></span>
<span class="line"><span>        template.setKeySerializer(new StringRedisSerializer());</span></span>
<span class="line"><span>        template.setHashValueSerializer(new GenericToStringSerializer&lt;&gt;(Object.class));</span></span>
<span class="line"><span>        template.setValueSerializer(new GenericToStringSerializer&lt;&gt;(Object.class));</span></span>
<span class="line"><span>        template.afterPropertiesSet();</span></span>
<span class="line"><span>        return template;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>RedisTemplate </code> 提供了多种类型的数据类型操作接口，满足多场景的业务需求。</p><div align="left"><img src="`+r+`" width="800px"></div><p>接下来就可以通过单元测试来验证缓存效果了</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@RunWith(SpringRunner.class)</span></span>
<span class="line"><span>@SpringBootTest(classes = StartApplication.class)</span></span>
<span class="line"><span>@FixMethodOrder(MethodSorters.NAME_ASCENDING)</span></span>
<span class="line"><span>public class UserMapperTest {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Resource</span></span>
<span class="line"><span>    private CacheService cacheService;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test1_set1() {</span></span>
<span class="line"><span>        boolean result = cacheService.set(&quot;k1&quot;, &quot;老马啸西风&quot;);</span></span>
<span class="line"><span>        System.out.println(result);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Test</span></span>
<span class="line"><span>    public void test2_get1() {</span></span>
<span class="line"><span>        String cacheResult = cacheService.get(&quot;k1&quot;);</span></span>
<span class="line"><span>        System.out.println(&quot;k1 的缓存结果：&quot; + cacheResult);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面讲的都是通过手动方式写入、删除、查询缓存，缓存的处理逻辑散落在业务代码中。有没有更简单的方式？比如调用一个方法，通过方法上标注的注解自动从缓存中获取，如果查找不到再从数据库查，并自动将结果预热到缓存中。</p><h2 id="spring-注解式缓存" tabindex="-1"><a class="header-anchor" href="#spring-注解式缓存"><span>Spring 注解式缓存</span></a></h2><p>首先通过 <code>RedisCacheConfiguration</code> 生成默认配置，然后对缓存进行自定义化配置，比如过期时间、缓存前缀、key/value 序列化方法等，然后构建出一个<code>RedisCacheManager</code>，其中通过<code>keySerializationPair</code> 方法为 key 配置序列化，<code>valueSerializationPair</code>方法为 value 配置序列化。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Bean</span></span>
<span class="line"><span>public CacheManager cacheManager(RedisConnectionFactory factory) {</span></span>
<span class="line"><span>    RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span></span>
<span class="line"><span>            .entryTtl(Duration.ofMinutes(30))</span></span>
<span class="line"><span>            .prefixKeysWith(&quot;cache:user:&quot;)</span></span>
<span class="line"><span>            .disableCachingNullValues()</span></span>
<span class="line"><span>            .serializeKeysWith(keySerializationPair())</span></span>
<span class="line"><span>            .serializeValuesWith(valueSerializationPair());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    Map map = new HashMap&lt;String, RedisCacheConfiguration&gt;();</span></span>
<span class="line"><span>    map.put(&quot;user&quot;, redisCacheConfiguration);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return RedisCacheManager.builder(factory)</span></span>
<span class="line"><span>            .withInitialCacheConfigurations(map).build();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private RedisSerializationContext.SerializationPair&lt;String&gt; keySerializationPair() {</span></span>
<span class="line"><span>    return RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer());</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>private RedisSerializationContext.SerializationPair&lt;Object&gt; valueSerializationPair() {</span></span>
<span class="line"><span>    return RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer());</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改、删除、查询等常见操作，官方都提供了对应的注解类，只需要在对应的方法上标注即可享受缓存功能，对研发同学及其便利，可以将精力专注到其它业务逻辑处理上。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@Component</span></span>
<span class="line"><span>@CacheConfig(cacheNames = &quot;user&quot;)</span></span>
<span class="line"><span>public class UserService {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @Cacheable(key = &quot;#id&quot;)</span></span>
<span class="line"><span>    public User getUserById(Long id) {</span></span>
<span class="line"><span>        User user = User.builder().id(id).userName(&quot;雪糕( &quot; + id + &quot;)&quot;).age(18).address(&quot;杭州&quot;).build();</span></span>
<span class="line"><span>        return user;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @CachePut(key = &quot;#user.id&quot;)</span></span>
<span class="line"><span>    public User updateUser(User user) {</span></span>
<span class="line"><span>        user.setUserName(&quot;雪糕（新名称）&quot;);</span></span>
<span class="line"><span>        return user;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    @CacheEvict(key = &quot;#id&quot;)</span></span>
<span class="line"><span>    public void deleteById(Long id) {</span></span>
<span class="line"><span>        System.out.println(&quot;db删除数据：&quot; + id);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>常用注解类</strong>：</p><p>1、 @CacheConfig 类级别的缓存注解，允许共享缓存名称</p><p>2、 @Cacheable 一般用于查询操作，根据 key 查询缓存</p><ul><li>如果 key 存在，直接返回缓存中的数据。</li><li>如果 key 不存在，查询 db，并将结果更新到缓存中。</li></ul><p>3、 @CachePut 一般用于更新和插入操作，每次都会请求 db，然后通过 key 对 Redis 进行写操作。</p><ul><li>如果 key 存在，更新缓存</li><li>如果 key 不存在，插入缓存</li></ul><p>4、 @CacheEvict 触发移除缓存</p><ul><li>根据 key 删除缓存中的数据。</li></ul><h2 id="项目源码" tabindex="-1"><a class="header-anchor" href="#项目源码"><span>项目源码</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>https://github.com/aalansehaiyang/spring-boot-bulking  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>模块：spring-boot-bulking-redis</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,74)]))}const b=n(t,[["render",d]]),v=JSON.parse('{"path":"/posts/interview/spring/springboot/Redis.html","title":"开箱即用，一键集成 Redis 缓存","lang":"zh-CN","frontmatter":{"title":"开箱即用，一键集成 Redis 缓存","description":"开箱即用，一键集成 Redis 缓存 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/spring/springboot/Redis.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"开箱即用，一键集成 Redis 缓存"}],["meta",{"property":"og:description","content":"开箱即用，一键集成 Redis 缓存 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"开箱即用，一键集成 Redis 缓存\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":8.52,"words":2555},"filePathRelative":"posts/interview/spring/springboot/Redis.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p><code>Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学可以关注&amp;收藏</code></p>","autoDesc":true}');export{b as comp,v as data};
