import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as p,o}from"./app-NomDibRt.js";const l="/vpress/images/arch/system/4-1.jpg",r="/vpress/images/arch/system/4-2.jpg",a="/vpress/images/arch/system/4-3.jpg",s="/vpress/images/arch/system/4-4.jpg",n="/vpress/images/arch/system/4-5.jpg",c="/vpress/images/arch/system/4-6.jpg",h="/vpress/images/arch/system/4-7.jpg",d={};function u(g,e){return o(),t("div",null,e[0]||(e[0]=[p('<h1 id="如何设计一个高并发系统" tabindex="-1"><a class="header-anchor" href="#如何设计一个高并发系统"><span>如何设计一个高并发系统？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>大家好，我是 老马</p><p>作为互联网从业者，高并发一直是我们绕不开的一个话题。</p><p>那么高并发系统都有哪些经验，掌握核心技巧，你可以快速成为一个架构师，主导一些高访问量系统的架构设计。</p><p>然后，升职加薪自然也就是水到渠成的事</p><div align="left"><img src="'+l+'" width="250px"></div><h2 id="一、负载均衡" tabindex="-1"><a class="header-anchor" href="#一、负载均衡"><span>一、负载均衡</span></a></h2><p>靠优化单台机器的<code>内存</code>、<code>CPU</code>、<code>磁盘</code>、<code>网络带宽</code>，使其发挥极致性能，已经不太现实。</p><p>正所谓 &quot;双拳难敌四手，恶虎还怕群狼&quot;，现在早已经是分布式时代，靠的是<code>shu量</code>取胜，也称之为<code>水平伸缩方案</code></p><p>这么多的系统，如何流量调度，这里的第一道入口就是负载均衡</p><blockquote><p>负载均衡，它的职责是将网络请求 “均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况</p></blockquote><p>通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。</p><div align="left"><img src="'+r+'" width="650px"></div><h3 id="常见的负载算法" tabindex="-1"><a class="header-anchor" href="#常见的负载算法"><span>常见的负载算法</span></a></h3><ul><li>随机算法</li><li>轮询算法</li><li>轮询权重算法</li><li>一致性哈希算法</li><li>最小连接</li><li>自适应算法</li></ul><h3 id="常用负载均衡工具" tabindex="-1"><a class="header-anchor" href="#常用负载均衡工具"><span>常用负载均衡工具</span></a></h3><ul><li>LVS</li><li>Nginx</li><li>HAProxy</li></ul><p>对于一些大型系统，一般会采用 DNS+四层负载+七层负载的方式进行多层次负载均衡。</p><h2 id="二、分布式微服务" tabindex="-1"><a class="header-anchor" href="#二、分布式微服务"><span>二、分布式微服务</span></a></h2><p>过去是一个大而全的系统，面对复杂的业务规则，我们采用<code>分而治之</code>的思想，通过SOA架构，将一个大的系统拆分成若干个微服务，粒度越来越小，称之为<code>微服务架构</code></p><p>每个微服务独立部署，服务和服务间采用轻量级的通信机制，如：标准的HTTP协议、或者私有的RPC协议。</p><p><strong>微服务特点：</strong></p><ul><li>按照业务划分服务，单个服务代码量小，业务单一，容易维护</li><li>每个微服务都有自己独立的基础组件，例如数据库</li><li>微服务之间的通信是通过HTTP协议或者私有协议，且具有容错能力</li><li>微服务有一套服务治理的解决方案，服务之间不耦合，可以随时加入和剔除</li><li>单个微服务能够集群化部署，有负载均衡的能力</li><li>整个微服务系统应该有完整的安全机制，包括用户验证，权限验证，资源保护</li><li>整个微服务系统有链路追踪的能力</li><li>有一套完整的实时日志系统</li></ul><blockquote><p>市面常用微服务框架有：Spring Cloud 、Dubbo 、kubernetes、gRPC、Thrift 等</p></blockquote><div align="left"><img src="'+a+'" width="650px"></div><p>这么多的微系统之间如何感知？这里面会引入注册中心。</p><blockquote><p>常用的注册中心有：Zookeeper、etcd、Eureka、Nacos、Consul</p></blockquote><p>万事有利就有弊，分布式微服务由于拆分的过细，引入一些复杂化问题需要关注：</p><ul><li>分布式事务</li><li>限流机制</li><li>熔断机制</li><li>网关</li><li>服务链路追踪</li></ul><h2 id="三、缓存机制" tabindex="-1"><a class="header-anchor" href="#三、缓存机制"><span>三、缓存机制</span></a></h2><p>性能不够，缓存来凑。要想快速提升性能，缓存肯定少不了</p><p>缓存能够带来性能的大幅提升，以 Memcache 为例，单台 Memcache 服务器简单的 key-value 查询能够达到 TPS 50000 以上；Redis性能数据是10W+ QPS</p><p>为什么缓存的速度那么快？</p><div align="left"><img src="'+s+'" width="650px"></div><p>从上图中发现，同机房两台服务器跑个来回，再从内存中顺序读取1M数据，共耗时0.75ms。如果从硬盘读取，做一次磁盘寻址需要10ms，再从磁盘里顺序读取1M数据需要30ms。可见，使用内存缓存性能上提高多个数量级，同时也能支持更高的并发量。</p><p><strong>常见的缓存分为本地缓存和分布式缓存，区别在与是否要走网络通讯。</strong></p><p>本地缓存是部署在应用服务器中，而我们应用服务器通常会部署多台，当数据更新时，我们不能确定哪台服务器本地中了缓存，更新或者删除所有服务器的缓存不是一个好的选择，所以我们通常会等待缓存过期。因此，这种缓存的有效期很短，通常为分钟或者秒级别，以避免返回前端脏数据。</p><p>相反，分布式缓存采用集群化管理，支持水平扩容，并提供客户端路由数据，数据一致性维护更好。虽然有不到 <code>1ms</code> 的网络开销，但比起其优势，这点损耗微不足道。</p><div align="left"><img src="'+n+'" width="650px"></div><p><strong>缓存更新常用策略？</strong></p><ul><li>Cache aside，通常会先更新数据库，然后再删除缓存，为了兜底还会设置缓存时间。</li><li>Read/Write through， 一般是由一个 Cache Provider 对外提供读写操作，应用程序不用感知操作的是缓存还是数据库。</li><li>Write behind，延迟写入，Cache Provider 每隔一段时间会批量写入数据库，大大提升写的效率。像操作系统的page cache也是类似机制。</li></ul><h2 id="四、分布式关系型数据库" tabindex="-1"><a class="header-anchor" href="#四、分布式关系型数据库"><span>四、分布式关系型数据库</span></a></h2><p>MySQL数据库采用B+数索引，三层结构，为了保证IO性能，一般建议单表存储 <code>千万</code> 条数据。</p><p>如果遇到单机数据库性能瓶颈，我们可以考虑分表。</p><p>分表又可以细分为 <strong>垂直分表</strong> 和 <strong>水平分表</strong> 两种形式。</p><h3 id="_1、垂直分表" tabindex="-1"><a class="header-anchor" href="#_1、垂直分表"><span>1、垂直分表</span></a></h3><p>数据表垂直拆分就是纵向地把一张表中的列拆分到多个表，<strong>表由“宽”变“窄”</strong>，简单来讲，就是将大表拆成多张小表，一般会遵循以下几个原则：</p><ul><li>冷热分离，把常用的列放在一个表，不常用的放在一个表。</li><li>字段更新、查询频次拆分</li><li>大字段列独立存放</li><li>关系紧密的列放在一起</li></ul><h3 id="_2、水平分表" tabindex="-1"><a class="header-anchor" href="#_2、水平分表"><span>2、水平分表</span></a></h3><p>表结构维持不变，对数据行进行切分，将表中的某些行切分到一张表中，而另外的某些行又切分到其他的表中，也就是说拆分后数据集的并集等于拆分前的数据集。</p><p><strong>分库分表技术点：</strong></p><ul><li>SQl组合。因为是逻辑表名，需要按分表键计算对应的物理表编号，根据逻辑重新组装动态的SQL</li><li>数据库路由。如果采用分库，需要根据逻辑的分表编号计算数据库的编号</li><li>结果合并。如果查询没有传入指定的分表键，会全库执行，此时需要将结果合并再输出。</li></ul><p><strong>目前市面有很多的开源框架，大致分为两种模式：</strong></p><ul><li><p>Proxy模式。SQL 组合、数据库路由、执行结果合并等功能全部存放在一个代理服务中，业务方可以当做。</p><ul><li>优点：支持多种语言。升级方便。对业务代码无侵入。</li><li>缺点：额外引入一个中间件，容易形成流量瓶颈，安全风险较高，有运维成本</li></ul></li><li><p>Client 模式。常见是 <code>sharding-jdbc</code>，业务端系统只需要引入一个jar包即可，按照规范配置路由规则。jar 中处理 SQL 组合、数据库路由、执行结果合并等相关功能。</p><ul><li>优点：简单、轻便。不存在流量瓶颈，减少运维成本</li><li>缺点：单语言，升级不方便。</li></ul></li></ul><p><strong>实现思路：</strong></p><p>1、如何选择分表键。</p><p>数据尽量均匀分布在不同表或库、跨库查询操作尽可能少、这个字段的值不会变。比如电商订单采用user_id。</p><p>2、分片策略。</p><p>根据范围分片、根据 hash 值分片、根据 hash 值及范围混合分片</p><p>3、如何编写业务代码。结合具体的业务实现。</p><p>4、历史数据迁移</p><ul><li>增量数据监听 binlog，然后通过 canal 通知迁移程序开始增量数据迁移</li><li>开启任务，全量数据迁移</li><li>开启双写，并关闭增量迁移任务</li><li>读业务切换到新库</li><li>线上运行一段时间，确认没有问题后，下线老库的写操作</li></ul><blockquote><p><strong>有一种说法：数据量大，就分表；并发高，就分库</strong></p></blockquote><p>在实际的业务开发中，要做好数据量的增长预测，做好技术方案选型。另外，在引入分表方案后，要考虑数据倾斜问题，这个跟分表键有很大关系，避免数据分布不均衡影响系统性能。</p><h2 id="五、分布式消息队列" tabindex="-1"><a class="header-anchor" href="#五、分布式消息队列"><span>五、分布式消息队列</span></a></h2><p>并不是所有的调用都要走同步形式，对于时间要求不高、或者非核心逻辑，我们可以采用<code>异步</code>处理机制。</p><p>也就衍生出消息队列。</p><div align="left"><img src="'+c+'" width="650px"></div><p>消息队列主要有三种角色：生产者、消息队列、消费者。</p><p>生产端核心的逻辑处理完后，会封装一个MQ消息，发送到消息队列。下游系统，如果关心这个事件，只需要订阅这个 topic ，便可以收到消息，进行后续的业务逻辑处理。</p><p>两者之间通过<code>消息中间件</code>完成了解耦，系统的扩展性非常高。</p><p><strong>常用的消息框架有哪些？</strong></p><blockquote><p>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaQ，RocketMQ、Pulsar 等</p></blockquote><p><strong>消息队列的应用场景？</strong></p><ul><li>1、异步处理。将一个请求链路中的非核心流程，拆分出来，异步处理，减少主流程链路的处理逻辑，缩短RT，提升吞吐量。如：注册新用户发短信通知。</li><li>2、削峰填谷。避免流量暴涨，打垮下游系统，前面会加个消息队列，平滑流量冲击。比如：秒杀活动。生活中像电源适配器也是这个原理。</li><li>3、应用解耦。两个应用，通过消息系统间接建立关系，避免一个系统宕机后对另一个系统的影响，提升系统的可用性。如：下单异步扣减库存</li><li>4、消息通讯。内置了高效的通信机制，可用于消息通讯。如：点对点消息队列、聊天室。</li></ul><h2 id="六、cdn" tabindex="-1"><a class="header-anchor" href="#六、cdn"><span>六、CDN</span></a></h2><p>CDN 全称 （Content Delivery Network），内容分发网络。</p><p>目的是在现有的网络中增加一层网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</p><blockquote><p>CDN = 镜像（Mirror）+缓存（Cache）+整体负载均衡（GSLB）</p></blockquote><p>CDN都以缓存网站中的静态数据为主，如：CSS、JS、图片和静态页面等数据。用户从主站服务器中请求到动态内容后，再从CDN下载静态数据，从而加速网页数据内容的下载速度。</p><div align="left"><img src="'+h+'" width="650px"></div><p><strong>主要特点：</strong></p><ul><li>本地Cache加速</li><li>镜像服务</li><li>远程加速</li><li>带宽优化</li><li>集群抗攻击</li></ul><p><strong>应用场景</strong></p><ul><li>网站站点/应用加速</li><li>视音频点播/大文件下载分发加速</li><li>视频直播加速</li><li>移动应用加速</li></ul><h2 id="七、其他" tabindex="-1"><a class="header-anchor" href="#七、其他"><span>七、其他</span></a></h2><p>作为补充，像<code>分布式文件系统</code>、<code>大数据</code>、<code>NoSQL</code>、<code>NewSQL</code>，慢慢也开始成为高并发系统的周围框架生态补充。</p>',88)]))}const _=i(d,[["render",u]]),f=JSON.parse('{"path":"/posts/interview/arch/system/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%EF%BC%9F.html","title":"如何设计一个高并发系统？","lang":"zh-CN","frontmatter":{"title":"如何设计一个高并发系统？","description":"如何设计一个高并发系统？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 大家好，我是 老马 作为互联网从业者，高并发一直是我们绕不开的一个话题。 那么高并发系统都有哪些经验，掌握核心技巧，你可以快速成为一个架构师，主导一些高访问量系统的架构设计。 然后，升职加薪自然也就是水到渠成的事 一、负...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/system/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"如何设计一个高并发系统？"}],["meta",{"property":"og:description","content":"如何设计一个高并发系统？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 大家好，我是 老马 作为互联网从业者，高并发一直是我们绕不开的一个话题。 那么高并发系统都有哪些经验，掌握核心技巧，你可以快速成为一个架构师，主导一些高访问量系统的架构设计。 然后，升职加薪自然也就是水到渠成的事 一、负..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何设计一个高并发系统？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":9.81,"words":2944},"filePathRelative":"posts/interview/arch/system/如何设计一个高并发系统？.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>大家好，我是 老马</p>\\n<p>作为互联网从业者，高并发一直是我们绕不开的一个话题。</p>\\n<p>那么高并发系统都有哪些经验，掌握核心技巧，你可以快速成为一个架构师，主导一些高访问量系统的架构设计。</p>","autoDesc":true}');export{_ as comp,f as data};
