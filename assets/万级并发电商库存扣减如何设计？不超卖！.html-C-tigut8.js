import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as t,o}from"./app-NomDibRt.js";const d="/vpress/images/arch/business/2-2.png",a="/vpress/images/arch/business/2-3.png",n="/vpress/images/arch/business/2-4.png",r="/vpress/images/arch/business/2-5.png",l="/vpress/images/arch/business/2-6.png",p="/vpress/images/arch/business/2-7.png",c={};function h(u,e){return o(),i("div",null,e[0]||(e[0]=[t('<h1 id="万级并发电商库存扣减如何设计-不超卖" tabindex="-1"><a class="header-anchor" href="#万级并发电商库存扣减如何设计-不超卖"><span>万级并发电商库存扣减如何设计？不超卖！</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>随着中国消费认知的不断升级，网购走近千家万户，越来越被人们所接受。淘宝、唯品会、考拉、京东、拼多多等逐渐成为我们生活的重要组成部分。</p><p>除了常规的购物下单外，这些电商平台还经常搞一些双十一活动，秒杀、大促、限时购，各种营销玩法，层出不穷。</p><p><strong>今天就来跟大家聊一聊电商技术里的库存扣减</strong></p><div align="left"><img src="'+d+'" width="650px"></div><p>当有很多人同时在买一件商品时（假设库存充足），每个人几乎同时下单成功，给人一种并行的感觉。但真实情况，<strong>库存只是一个数值，无论是存在mysql数据库还是redis缓存，减值时都要控制顺序，只能串行来扣减，当然为了保证安全性，会设计一些锁控制操作。</strong></p><h2 id="库存扣减关键技术点" tabindex="-1"><a class="header-anchor" href="#库存扣减关键技术点"><span>库存扣减关键技术点</span></a></h2><ul><li>同一个SKU，库存数量是共享</li><li>剩余库存要大于等于本次扣减的数量，否则会出现<code>超卖</code>现象，引发资损</li><li>对同一个数量多用户并发扣减时，要注意并发安全，保证数据的一致性</li><li>类似于秒杀这样高QPS的扣减场景，要保证性能与高可用</li><li>对于购物车下单场景，多个商品库存批量扣减，要保证事务</li><li>如果有<code>交易退款</code>，保证库存扣减可以返还 <ul><li>返还的数据总量不能大于扣减的总量</li><li>返还要保证幂等</li><li>可以分多次返还</li></ul></li></ul><h2 id="数据库扣减方案" tabindex="-1"><a class="header-anchor" href="#数据库扣减方案"><span>数据库扣减方案</span></a></h2><p>主要是依赖数据库特性来保证扣减的一致性，逻辑简单，开发部署成本很低。</p><p><strong>依赖的数据库特性：</strong></p><ul><li>依赖数据库的乐观锁（比如：版本号或者库存数量）保证数据并发扣减的强一致性</li><li>借助事务特性，针对购物车下单批量扣减时，部分扣减失败，数据回滚</li></ul><div align="left"><img src="'+a+`" width="500px"></div><blockquote><p>最上面会查询当前的剩余库存（可能不准确，但没关系，这里只是第一步粗略校验），前置校验，如果已经没有库存，前置拦截生效，减少对数据库的写操作。毕竟<code>读操作</code>不涉及加锁，并发性能高。数据库包含两张表：库存表、流水表。</p></blockquote><p><strong>1、库存表</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>sku_id</td><td>商品规格id</td></tr><tr><td>leaved_amount</td><td>剩余可购买数量</td></tr></tbody></table><ul><li>当用户进行取消订单、申请退货退款，需要把数量加回来</li><li>如果商家补过库存，需要在此基础上额外加上增量库存</li></ul><p><strong>2、 流水表</strong></p><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>主键id</td></tr><tr><td>sku_id</td><td>商品规格id</td></tr><tr><td>order_detail_id</td><td>订单明细id</td></tr><tr><td>quantity_trade</td><td>本次购买扣减的数量</td></tr></tbody></table><ul><li>用于查看明细、对账、盘货、排查问题等</li><li>在扣减后，某些场景下需要返还也依赖流水</li></ul><p><strong>单条商品的扣减SQL大致如下：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>update inventory </span></span>
<span class="line"><span>set leaved_amount = leaved_amount - #{count} </span></span>
<span class="line"><span>where sku_id=&#39;123&#39; and leaved_amount &gt;= #{count}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>此 SQL 采用 类似乐观锁的方式实现了原子性，在 where 条件里判断此次购买的数量小于等于剩余的数量。在扣减服务的代码里，判断此 SQL 的返回值，如果值为 1 ，表示扣减成功。否则，返回 0 ，表示库存不足，需要回滚。</p></blockquote><p><strong>扣减成功后，需要记录扣减流水，并与订单明细记录做关联。</strong></p><ol><li><p>当用户归还数量时，需要带回此编号，用来标识此次返还属于历史上的具体哪次扣减。</p></li><li><p>进行幂等性控制。当用户调用扣减接口出现超时时，因为用户不知道是否成功，用此编号进行重试或反查。在重试时，使用此编号进行标识防重。</p></li></ol><h2 id="【数据库扣减方案】第一次升级" tabindex="-1"><a class="header-anchor" href="#【数据库扣减方案】第一次升级"><span>【数据库扣减方案】第一次升级</span></a></h2><p>举个极端的例子：最新款iPhone秒杀，库存只有5件，活动期间峰值QPS预估在10W，活动结束后，上面的流水表最终只会插入5条记录，但是查询的QPS却接近 <code>10W QPS</code>，读的压力非常大。</p><p>所以，数据库扣减方案第一次升级主要是针对<code>库存前置校验</code>模块的优化，作为前置拦截器，承载的流量很大，如果将流量全部压到主库上，很容易把数据压垮。我们考虑把数据库架构升级。</p><div align="left"><img src="`+n+'" width="500px"></div><p>采用了<code>读写分离</code>方式，新增加了一套从库，借助mysql自带的数据同步能力。<code>库存校验</code>时读取从数据库。</p><p>当然，数据同步有一定的时间延迟，从库的数据新鲜度有一定的滞后性，所以这个<code>库存校验</code>结果并不一定准确，但却能拦截大部分的<code>无效流量</code>。最终能不能成功购买，由主库的<code>乐观扣减SQL</code>来控制，并不会影响最终扣减的准确性。大大减轻主库的查询压力。</p><h2 id="【数据库扣减方案】第二次升级" tabindex="-1"><a class="header-anchor" href="#【数据库扣减方案】第二次升级"><span>【数据库扣减方案】第二次升级</span></a></h2><p>引入了从库，确实能分摊主库很大一部分压力，但是面对秒杀这种万级QPS流量，mysql的<code>千级TPS</code>根本支撑不了，需要进一步升级读取的性能。</p><div align="left"><img src="'+r+'" width="500px"></div><ul><li>此时引入缓存中间件（如Redis），将mysql的数据定时同步到缓存中</li><li><code>库存校验</code>模块，从redis中查询剩余的库存数据。由于缓存基于内存操作，性能比数据库高出几个数量级，单台redis实例可以达到10W QPS的读性能</li></ul><p>该方案升级后，基本上解决了在前置<code>库存校验</code>环节及<code>获取库存数量接口</code>的性能问题，提高了系统整体性能，提供较好的用户体验。</p><p><strong>补充说明：</strong></p><p>如果并发量还是很高的话，可以考虑引入<code>缓存集群</code>，将不同的<code>秒杀商品sku</code>尽量均匀分布在多个redis节点中，从而分摊掉整体的峰值QPS压力。（参考缓存热点的解决方案）</p><p><strong>数据库方案的优点：</strong></p><ul><li>借助数据库的<code>ACID</code>特性，业务上不会出现<code>超卖</code>、<code>少买</code>现象</li><li>实现简单，如果项目工期紧张，或者开发资源不足情况下非常适用</li></ul><p><strong>数据库方案的不足：</strong></p><ul><li>如果参与秒杀的SKU非常多，最后的写操作都是基于<code>库存主库</code>，性能压力会比较大。</li></ul><h2 id="纯缓存扣减方案" tabindex="-1"><a class="header-anchor" href="#纯缓存扣减方案"><span>纯缓存扣减方案</span></a></h2><p>Redis采用单线程的事件模型，具有<code>原子性</code>的特性。当有多个客户端给Redis发送命令时，Redis会按照接收到的顺序<code>串行化</code>执行。对于还未被调度的命令，则放在队列里<code>排队等待</code>。</p><p>库存扣减为了保证数据并发安全，要求原子性，而<code>Redis</code>正好满足扣减类的特殊性要求，是个不错的技术选型。</p><p>下面，我们简单来看看基于<code>Redis</code>如何来设计库存扣减？</p><div align="left"><img src="'+l+`" width="500px"></div><p><strong>首先，设计Redis的数据模型：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>剩余库存（k-v结构）：</span></span>
<span class="line"><span>key：sku_leaved_amount_{sku_id}</span></span>
<span class="line"><span>value：剩余的库存数值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>流水（hash结构）：</span></span>
<span class="line"><span>key：inventory_flow_{sku_id}</span></span>
<span class="line"><span>hash—key：订单明细id（不同业务场景的全局性id，用来做幂等控制）</span></span>
<span class="line"><span>hash—value：本次购买的数量</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于购物车下单，多个sku批量扣减，我们需要按单个sku循环发起Redis调用。但是多个Redis命令无法保证原子性。我们可以采用<code>lua脚本</code>形式，将这些命令打包到一个脚本中，作为一个命令发送给Redis执行，从而保证了原子性。</p><blockquote><p>lua 是一个类似 JavaScript、Shell 等的解释性语言，它可以完成 Redis 已有命令不支持的功能。用户在编写完 lua 脚本之后，将此脚本上传至 Redis 服务端，服务端会返回一个标识码代表此脚本。在实际执行具体请求时，将数据和此标识码发送至 Redis 即可。Redis 会和执行普通命令一样，采用单线程执行此 lua 脚本和对应数据。</p></blockquote><p><strong>Lua 脚本执行流程：</strong></p><p>批量扣减是对单个扣减的循环调用，所以这里介绍的流程只讲单次扣减的处理步骤。</p><ol><li>首先根据<code>订单明细id</code>查询扣减流水，是否已经操作过，做幂等性校验</li><li>然后查询sku的剩余库存，并根据<code>下单购买数</code>做校验，只要有一个sku 数量不足，则返回失败</li><li>修改所有sku的缓存中的剩余库存数</li><li>缓存中插入扣减流水记录</li></ol><p>当Redis扣减成功后，应用程序再将此次扣减<code>异步化</code>保存到数据库中，持久化存储，毕竟Redis只是临时性存储，有宕机风险，会丢失数据。</p><p><strong>缓存方案利弊分析：</strong></p><ul><li><code>Redis</code>缓存方案，借助了缓存的<code>高性能</code>，承载更高的并发。但是没有数据库的<code>ACID</code>特性，极端情况下，可能出现<code>少卖</code>情况</li><li>为了避免<code>少卖</code>情况发生，<code>纯缓存方案</code>需要做大量的对账、异常处理的设计，系统复杂度增加很多。</li><li><code>纯缓存方案</code>适合一些高并发、大流量场景，但对数据准确度要求不是特别苛刻的业务场景。</li></ul><p><strong>风险：</strong></p><p>上述<code>Lua脚本</code>把多条命令打包在一起，虽然保证了原子性，但不具备<code>事务回滚</code>特性。比如，库存扣减成功了，此时<code>Redis宕机</code>，扣减流水并没有插入成功，应用程序认为本次<code>Redis调用</code>是<code>失败</code>的，前台给用户反馈错误提示，但是已经扣减的数量不会回滚。当Redis故障修复后，再次启动，此时恢复的数据已经存在不一致了。需要结合<code>Redis</code>和<code>数据库</code>做数据核对check，并结合扣减服务的日志，做数据的增量修复。</p><h2 id="基于分库分表的扣减方案" tabindex="-1"><a class="header-anchor" href="#基于分库分表的扣减方案"><span>基于分库分表的扣减方案</span></a></h2><p>上面提到的数据库方式是基于<code>单库单表</code>玩法，虽然借助<code>ACID</code>特性能保证数据的一致性，但是单台mysql的并发能力有限，如何提升性能？</p><p>除了<code>纯缓存</code>化方案外，我们还可以考虑将<code>库存表</code>进行<code>水平拆分</code>，分摊洪峰压力。</p><div align="left"><img src="`+p+'" width="650px"></div><p>假如库存表的QPS要求是1.6万，经过拆分成16张表后，如果数据分布均匀，每个物理表预计处理1000 QPS，处于mysql单实例的承载范围之内。</p><p>另外拆分后，单表的数据量也会相应减少很多，假如分表前有一个亿数据，分表后每张表不到1千万，索引查询性能也会快很多。</p><p>注意：</p><blockquote><p>同一次扣减业务，<code>库存扣减</code>和<code>插入流水</code>要放在同一个分库中，通过事务保证一致性，满足同时成功或同时失败。如果数据分布和业务请求足够均匀，理论上经过分库分表设计后，整个系统的吞吐量将会是线性的增长，主要取决于分表实例的数量。</p></blockquote><h2 id="其他扣减方案" tabindex="-1"><a class="header-anchor" href="#其他扣减方案"><span>其他扣减方案</span></a></h2><p>还有其他的一些解决方案，这里只是提供一些思路，方案细节就不展开了</p><p>1、如果某个sku_id的库存扣减过热，单台实例支撑不了**（mysql官方测评：一般单行更新的QPS在500以内）**，可以考虑将一个sku的大库存拆分成N份，放在不同的库中（也就是说所有子库的库存数总和才是一件sku的真实库存），由于前台的访问流量非常大，按照<code>均分原则</code>，每个子库分到的流量应该差不多。上层路由时只需要在<code>sku_id</code>后面拼接<code>一个范围内的随机数</code>，即可找到对应的子库，有效减轻系统压力。</p><p>2、单条sku库存记录更新过热，也可以采用批量提交方式，将多次扣减累计计数，集中成一次扣减，<strong>从而实现了将串行处理变成了批处理</strong>，也可以大大减轻数据库压力。</p><p>3、引入<code>RocketMQ</code>消息队列，经过前置校验后，如果有剩余库存，则把创建订单的操作封装成消息发送给MQ，订单系统从RocketMQ中以特定的频率消费，创建订单，该方案有一定的延迟性。</p><h2 id="资料" tabindex="-1"><a class="header-anchor" href="#资料"><span>资料</span></a></h2><ul><li><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=595&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6137" target="_blank" rel="noopener noreferrer">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=595&amp;sid=20-h5Url-0&amp;buyFrom=2&amp;pageId=1pz4#/detail/pc?id=6137</a></li><li><a href="https://cloud.tencent.com/developer/article/1366705" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1366705</a></li><li><a href="https://cloud.tencent.com/developer/article/1700583" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1700583</a></li><li><a href="https://zhuanlan.zhihu.com/p/134012175" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/134012175</a></li><li><a href="https://cloud.tencent.com/developer/article/1700583" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1700583</a></li></ul>',75)]))}const g=s(c,[["render",h]]),v=JSON.parse('{"path":"/posts/interview/arch/business/%E4%B8%87%E7%BA%A7%E5%B9%B6%E5%8F%91%E7%94%B5%E5%95%86%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F%E4%B8%8D%E8%B6%85%E5%8D%96%EF%BC%81.html","title":"万级并发电商库存扣减如何设计？不超卖！","lang":"zh-CN","frontmatter":{"title":"万级并发电商库存扣减如何设计？不超卖！","description":"万级并发电商库存扣减如何设计？不超卖！ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 随着中国消费认知的不断升级，网购走近千家万户，越来越被人们所接受。淘宝、唯品会、考拉、京东、拼多多等逐渐成为我们生活的重要组成部分。 除了常规的购物下单外，这些电商平台还经常搞一些双十一活动，秒杀、大促、限...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/business/%E4%B8%87%E7%BA%A7%E5%B9%B6%E5%8F%91%E7%94%B5%E5%95%86%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F%E4%B8%8D%E8%B6%85%E5%8D%96%EF%BC%81.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"万级并发电商库存扣减如何设计？不超卖！"}],["meta",{"property":"og:description","content":"万级并发电商库存扣减如何设计？不超卖！ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 随着中国消费认知的不断升级，网购走近千家万户，越来越被人们所接受。淘宝、唯品会、考拉、京东、拼多多等逐渐成为我们生活的重要组成部分。 除了常规的购物下单外，这些电商平台还经常搞一些双十一活动，秒杀、大促、限..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"万级并发电商库存扣减如何设计？不超卖！\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":10.99,"words":3298},"filePathRelative":"posts/interview/arch/business/万级并发电商库存扣减如何设计？不超卖！.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>随着中国消费认知的不断升级，网购走近千家万户，越来越被人们所接受。淘宝、唯品会、考拉、京东、拼多多等逐渐成为我们生活的重要组成部分。</p>\\n<p>除了常规的购物下单外，这些电商平台还经常搞一些双十一活动，秒杀、大促、限时购，各种营销玩法，层出不穷。</p>","autoDesc":true}');export{g as comp,v as data};
