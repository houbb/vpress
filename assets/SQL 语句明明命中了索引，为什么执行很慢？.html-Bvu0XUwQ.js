import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as n}from"./app-NomDibRt.js";const d="/vpress/images/middleware/mysql/22-1.jpeg",o="/vpress/images/middleware/mysql/22-2.jpeg",r="/vpress/images/middleware/mysql/22-3.jpeg",t="/vpress/images/middleware/mysql/22-4.jpeg",l="/vpress/images/middleware/mysql/22-5.jpeg",p="/vpress/images/middleware/mysql/22-6.jpeg",c="/vpress/images/middleware/mysql/22-7.jpeg",m="/vpress/images/middleware/mysql/22-8.jpeg",h="/vpress/images/middleware/mysql/22-9.jpeg",g="/vpress/images/middleware/mysql/22-10.jpeg",u="/vpress/images/middleware/mysql/22-11.jpeg",b="/vpress/images/middleware/mysql/22-12.jpeg",_="/vpress/images/middleware/mysql/22-13.jpeg",v={};function y(E,e){return n(),i("div",null,e[0]||(e[0]=[a('<h1 id="sql-语句明明命中了索引-为什么执行很慢" tabindex="-1"><a class="header-anchor" href="#sql-语句明明命中了索引-为什么执行很慢"><span>SQL 语句明明命中了索引，为什么执行很慢？</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>我们都知道，业务开发涉及到数据库的<code>SQL</code>操作时，一定要 <code>review</code> 是否命中索引。否则，会走 <code>全表扫描</code>，如果表数据量很大时，会慢的要死。</p><p><strong>假如命中了索引呢？是不是就不会有慢查询？</strong></p><div align="left"><img src="'+d+`" width="200px"></div><p><strong>殊不知，我们习以为常的常识有时也会误导我们！</strong></p><p>人生好难！</p><p>聊这个话题，要有一定技术基础，需了解 B+ 树的存储结构</p><p>如果不是很清楚的话，先看下之前一篇文章，有详细介绍</p><p><a href="https://mp.weixin.qq.com/s/IdpY7CPxyqRNx3BYYxl2Ow" target="_blank" rel="noopener noreferrer">面试题：mysql 一棵 B+ 树可以存多少条数据？</a></p><h2 id="工作准备-建表-造数据" tabindex="-1"><a class="header-anchor" href="#工作准备-建表-造数据"><span>工作准备：建表，造数据</span></a></h2><p>首先创建一张 user 表，并创建一个 <code>id</code>的主键索引，和一个 <code>user_name</code> 的普通索引。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE \`user\` (</span></span>
<span class="line"><span>  \`id\` bigint(20) NOT NULL AUTO_INCREMENT,</span></span>
<span class="line"><span>  \`user_name\` varchar(128) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;用户名&#39;,</span></span>
<span class="line"><span>  \`age\` int(11) NOT NULL  COMMENT &#39;年龄&#39;,</span></span>
<span class="line"><span>  \`address\` varchar(128) COMMENT &#39;地址&#39;,</span></span>
<span class="line"><span>   PRIMARY KEY (\`id\`),</span></span>
<span class="line"><span>   key \`idx_user_name\` (user_name),</span></span>
<span class="line"><span>) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COMMENT=&#39;用户表&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动程序，往 <code>user</code> 表中插入 10000 条数据。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>@GetMapping(&quot;/insert_batch&quot;)</span></span>
<span class="line"><span>public Object insertBatch(@RequestParam(&quot;batch&quot;) int batch) {</span></span>
<span class="line"><span>    for (int j = 1; j &lt;= batch; j++) {</span></span>
<span class="line"><span>        List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>        for (int i = 1; i &lt;= 100; i++) {</span></span>
<span class="line"><span>            User user = User.builder().userName(&quot;老马-&quot; + ((j - 1) * 100 + i)).age(29).address(&quot;上海&quot;).build();</span></span>
<span class="line"><span>            userList.add(user);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        userMapper.insertBatch(userList);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return &quot;success&quot;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="慢查询" tabindex="-1"><a class="header-anchor" href="#慢查询"><span>慢查询</span></a></h2><p>在分析原因前，我们先来了解 mysql 慢查询是什么？如何定义的？</p><p><strong>慢查询定义：</strong></p><blockquote><p>MySQL的慢查询日志是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。</p></blockquote><p><strong>慢查询相关参数：</strong></p><ul><li>slow_query_log：是否开启慢查询日志，1表示开启，0表示关闭。</li><li>log-slow-queries：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log</li><li>long_query_time：慢查询阈值，当查询时间高于设定的阈值时，记录到日志</li><li>log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）</li></ul><p>默认情况下<code>slow_query_log </code>的值为OFF，表示慢查询日志是禁用的，可以通过设置<code>slow_query_log </code>的值来开启，如下所示：</p><div align="left"><img src="`+o+'" width="800px"></div><blockquote><p>使用set global <code>slow_query_log </code>=1 开启了慢查询日志只对当前数据库生效，如果MySQL重启后则会失效。如果要永久生效，必须修改配置文件 <code>my.cnf</code></p></blockquote><p><code>long_query_time </code>的默认值为10 秒，支持二次修改。线上我们一般会设置成1秒，如果业务对延迟敏感的话，我们根据需要设置一个更低的值。</p><div align="left"><img src="'+r+'" width="800px"></div><h2 id="开始实验" tabindex="-1"><a class="header-anchor" href="#开始实验"><span>开始实验</span></a></h2><p>首先看下以下几种场景的SQL语句执行时，索引的命中情况。</p><p>1、执行<code>explain select * from user;</code>，发现 <code>key</code> 这列为NULL，说明了没有命中索引，走了全表扫描。</p><div align="left"><img src="'+t+'" width="800px"></div><p>2、执行 <code>explain select * from user where id=10;</code>，发现 <code>key</code> 这列为 <code>PRIMARY</code>，说明使用了主键索引。</p><div align="left"><img src="'+l+'" width="800px"></div><p>3、执行 <code> explain select user_name from user;</code>，发现 <code>key</code> 这列为 <code>idx_user_name</code>，说明使用了二级普通索引。</p><div align="left"><img src="'+p+'" width="800px"></div><p>但是，实验发现，虽然走了二级索引，但是 <code>rows</code> 扫描行为 9968，说明走了全表扫描。性能很差。</p><p>本文测试只造了 1W 条数据，如果线上环境有个千万级数据量，那估计要好几秒才能响应结果。</p><p>如果请求并发量很高，很容易引发数据库连接无法及时释放，导致客户端无法获取数据库连接而报错。</p><h2 id="命中了索引-依然很慢" tabindex="-1"><a class="header-anchor" href="#命中了索引-依然很慢"><span>命中了索引，依然很慢</span></a></h2><p>我们知道所有的数据都是存储在 B+ 索引树上，当执行 <code>explain select * from user where id&gt;0;</code> 时，发现使用了主键索引。</p><div align="left"><img src="'+c+'" width="800px"></div><p>mysql 优化器根据主键索引找到第一个 <code>id&gt;0</code> 的值，虽然走了索引但其实还是全表扫描。</p><p>没命中索引会走全表扫描，命中了索引也可能走全表扫描。</p><div align="left"><img src="'+m+'" width="300px"></div><p><strong>看来是否命中索引，并不是评判 SQL 性能好坏的唯一标准。</strong></p><p>其实，还有一个重要指标，那就是 <code>扫描行数</code>。</p><p>当一个表很大时，不仅要关注是否有索引，还要关注索引的<code>过滤性</code>是否足够好。</p><h2 id="回表-优化" tabindex="-1"><a class="header-anchor" href="#回表-优化"><span><code>回表</code> 优化</span></a></h2><p>首先为<code>user</code>表 增加一个 <code>user_name</code> 和 <code>age</code> 的联合索引。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ALTER TABLE `user` ADD INDEX idx_user_name_age ( `user_name`,`age` );</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div align="left"><img src="'+h+'" width="500px"></div><p>执行 <code> explain select * from user where user_name like &#39;老马-1%&#39; and age =29;</code></p><div align="left"><img src="'+g+'" width="850px"></div><p><strong>执行流程：</strong></p><ul><li>① 首先在 <code>idx_user_name_age</code> 索引树，查找第一个以 <code>老马-1</code> 开头的记录对应的主键id</li><li>② 根据主键id从主键索引树找到整行记录，并根据<code>age</code>做判断过滤，等于29则留下，否则丢弃。这个过程也称为<code>回表</code></li><li>③ 然后，在 <code>idx_user_name_age</code> 联合索引树上向右遍历，找到下一个主键id</li><li>④ 再执行第二步</li><li>⑤ 后面重复执行第三步、第四步，直到<code>user_name</code>不是以 <code>老马-1</code> 开头，则结束</li><li>⑥ 返回所有查询结果</li></ul><p><strong>分析：</strong></p><p>由于按<code>user_name</code> 的前缀匹配，<code>idx_user_name_age</code>二级索引中的 <code>age</code> 部分并没有发挥作用。导致了大量<code>回表</code>查询，性能较差。</p><p><strong>有什么优化策略：</strong></p><p>MySQL 5.6 版本引入一个 <code> Index Condition Pushdown Optimization</code></p><div align="left"><img src="'+u+'" width="800px"></div><blockquote><p><a href="https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html</a></p></blockquote><p><strong>优化后，执行流程：</strong></p><ul><li>① 首先在 <code>idx_user_name_age</code> 索引树，查找第一个以 <code>老马-1</code> 开头的索引记录</li><li>② 然后，判断这个索引记录中的 <code>age</code> 是否等于 29。如果是，<code>回表</code> 取出整行数据，作为后面的结果返回；如果不是，则丢弃</li><li>③ 在 <code>idx_user_name_age</code> 联合索引树上向右遍历，重复第二步，直到<code>user_name</code>不是以 <code>老马-1</code> 开头，则结束</li><li>④ 返回所有查询结果</li></ul><p>跟上面的过程差别，在于判断 <code>age 是否等于 29</code> 放在了遍历联合索引过程中进行，不需要回表判断，大大降低了回表的次数，提升性能。</p><p><code>当然这个优化依然没有绕开最左前缀原则，索引的过滤性仍然有提升空间。</code></p><p><strong>这时，我们需要引入一个叫 <code>虚拟列</code> 的概念。</strong></p><p>修改表结构：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ALTER TABLE `user` add user_name_first varchar(12) generated always as </span></span>\n<span class="line"><span>(left(user_name,6)) , add index(user_name_first,age);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div align="left"><img src="'+b+'" width="800px"></div><p>执行 <code>explain select * from user where user_name_first like &#39;老马-1%&#39; and age =29;</code></p><div align="left"><img src="'+_+'" width="800px"></div><p>比较发现，扫描行数 <code>row</code> 变小了，证明优化有效果。</p><h2 id="写在最后" tabindex="-1"><a class="header-anchor" href="#写在最后"><span>写在最后</span></a></h2><p><code>slow_query_log</code> 收集到的慢 SQL ，结合 <code>explain</code> 分析是否命中索引，结合扫描行数，有针对性的优化慢 SQL。</p><p>但是要注意一点，慢 SQL 日志中也可能有正常的 SQL，可能只是当时CPU等系统资源过载，影响到正常 SQL 的执行速度。</p><p>简单来讲，慢查询和索引没有必然联系，一个SQL语句的执行效率最终要看的是扫描行数。另外可以使用虚拟列和联合索引来提升复杂查询的执行效率</p>',76)]))}const w=s(v,[["render",y]]),q=JSON.parse('{"path":"/posts/interview/middleware/mysql/SQL%20%E8%AF%AD%E5%8F%A5%E6%98%8E%E6%98%8E%E5%91%BD%E4%B8%AD%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%9F.html","title":"SQL 语句明明命中了索引，为什么执行很慢？","lang":"zh-CN","frontmatter":{"title":"SQL 语句明明命中了索引，为什么执行很慢？","description":"SQL 语句明明命中了索引，为什么执行很慢？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们都知道，业务开发涉及到数据库的SQL操作时，一定要 review 是否命中索引。否则，会走 全表扫描，如果表数据量很大时，会慢的要死。 假如命中了索引呢？是不是就不会有慢查询？ 殊不知，我们...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mysql/SQL%20%E8%AF%AD%E5%8F%A5%E6%98%8E%E6%98%8E%E5%91%BD%E4%B8%AD%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%EF%BC%9F.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"SQL 语句明明命中了索引，为什么执行很慢？"}],["meta",{"property":"og:description","content":"SQL 语句明明命中了索引，为什么执行很慢？ 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 简介 我们都知道，业务开发涉及到数据库的SQL操作时，一定要 review 是否命中索引。否则，会走 全表扫描，如果表数据量很大时，会慢的要死。 假如命中了索引呢？是不是就不会有慢查询？ 殊不知，我们..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SQL 语句明明命中了索引，为什么执行很慢？\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":6.55,"words":1966},"filePathRelative":"posts/interview/middleware/mysql/SQL 语句明明命中了索引，为什么执行很慢？.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<h2>简介</h2>\\n<p>我们都知道，业务开发涉及到数据库的<code>SQL</code>操作时，一定要 <code>review</code> 是否命中索引。否则，会走 <code>全表扫描</code>，如果表数据量很大时，会慢的要死。</p>","autoDesc":true}');export{w as comp,q as data};
