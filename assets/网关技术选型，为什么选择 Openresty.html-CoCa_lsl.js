import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as i,o as a}from"./app-NomDibRt.js";const l="/vpress/images/arch/system/1-2.jpg",t="/vpress/images/arch/system/1-10.jpg",p="/vpress/images/arch/system/1-1.jpg",r="/vpress/images/arch/system/1-4.jpg",o="/vpress/images/arch/system/1-5.jpg",c="/vpress/images/arch/system/1-3.jpg",d="/vpress/images/arch/system/1-7.jpg",h="/vpress/images/arch/system/1-6.jpg",u="/vpress/images/arch/system/1-8.jpg",b="/vpress/images/arch/system/1-9.jpg",g={};function m(v,e){return a(),n("div",null,e[0]||(e[0]=[i('<h1 id="网关技术选型-为什么选择-openresty-事件驱动、协程" tabindex="-1"><a class="header-anchor" href="#网关技术选型-为什么选择-openresty-事件驱动、协程"><span>网关技术选型，为什么选择 Openresty ？事件驱动、协程...</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>互联网公司，不论体量大小如何，其内部的技术架构基本都是相似的，体现在以下几个方面：</p><ul><li>数据量过大，如何定制化存储</li><li>访问量高了，如何集群化部署，流量负载均衡</li><li>响应速度慢了，如何提高处理速度，引入多级缓存</li><li>如果机器多了，如何保证某台服务器突然抽风，不影响业务集群的服务稳定性</li></ul><p>麻雀虽小五脏俱全，今天要讲的网关，就是其中的关键一环，不论公司规模大小如何，基本都要有这个系统。</p><p>那么网关是干什么用的？</p><h2 id="什么是网关" tabindex="-1"><a class="header-anchor" href="#什么是网关"><span>什么是网关</span></a></h2><div align="left"><img src="'+l+'" width="650px"></div><p>网关是连接客户端与服务端的中间桥梁，将很多<code>通用地</code>、<code>非业务逻辑</code>抽离，前置到网关系统，减少了很多重复性开发工作，是整个网站的唯一流量入口。</p><p>为了提高系统的扩展性，网关通常采用组件式架构，高内聚低耦合。</p><p><strong>常用的组件功能：</strong></p><ul><li>黑名单拦截</li><li>日志</li><li>参数校验</li><li>鉴权</li><li>限流</li><li>负载均衡</li><li>路由转发</li><li>监控</li><li>灰度分流</li><li>多协议支持</li><li>熔断、降级、重试、数据聚合等</li></ul><div align="left"><img src="'+t+'" width="500px"></div><p>系统设计上一般采用<code>责任链</code>设计模式，定义好抽象接口，每个组件实现自己的专属功能，职责单一。并且根据不同的业务请求API，添加、删除一些节点，动态构建新的节点链，从而满足多样化的业务需求。</p><h2 id="网关选型" tabindex="-1"><a class="header-anchor" href="#网关选型"><span>网关选型</span></a></h2><p>1、Tomcat/Jetty+NIO+Servlet3</p><p>2、Nginx</p><p>3、Spring WebFlux</p><p>4、Soul</p><p>5、Spring cloud Gateway</p><p>6、Zuul</p><p>7、OpenResty</p><p>8、Kong</p><p>9、Netty 自建</p><p>各个框架的资料网上基本都有，考虑到篇幅限制，这里就不展开分析每个框架的优缺点（如果感兴趣，可以给我留言，人多的话我后面就单启一篇文章来讲一讲）。</p><p><strong>我们计划选型 OpenResty，主要有以下几个原因：</strong></p><ul><li>能实现跨网络的gRPC请求转发，底层采用 HTTP/2 协议</li><li>支持 SSL/TLS 证书加密，通讯安全</li><li>性能方面，支持较高的并发请求</li><li>性能开销低，延迟少</li></ul><h2 id="翻牌-openresty" tabindex="-1"><a class="header-anchor" href="#翻牌-openresty"><span>翻牌 OpenResty</span></a></h2><p>下图是 Netcraft 最新统计的 2021年10月 Web 服务器排行榜</p><blockquote><p>Netcraft 是一家总部位于英国巴斯始于 1995 年的互联网服务公司。 该公司官网每月发布的调研数据报告：Web Server Survey 系列 已成为当今人们了解全球网站的服务器市场份额</p></blockquote><div align="left"><img src="'+p+'" width="700px"></div><blockquote><p>来源：<a href="https://news.netcraft.com/archives/2021/10/15/october-2021-web-server-survey.html" target="_blank" rel="noopener noreferrer">https://news.netcraft.com/archives/2021/10/15/october-2021-web-server-survey.html</a></p></blockquote><p>OpenResty 现在全球排名第三，由于将Nginx扩展成<code>动态服务器</code>，发展势头很猛。</p><p>我们常用的 12306 的余票查询功能，京东的商品详情页，这些高流量的背后，其实都是 OpenResty 在提供服务。</p><p>OpenResty 最擅长的是部署在流量入口处，处理各种高并发流量。</p><p>接下来，我们来深入了解下这个框架</p><h2 id="openresty-诞生起因" tabindex="-1"><a class="header-anchor" href="#openresty-诞生起因"><span>OpenResty 诞生起因</span></a></h2><div align="left"><img src="'+r+'" width="600px"></div><blockquote><p>nginx 采用 master-worker 进程模型，分工明确，职责单一，也是其具备高性能的原因之一。</p></blockquote><p>1、master 进程</p><p>管理进程，处理指令如：<code>-s reload</code>、<code>-s stop</code>，通过进程间通信，将管理指令发送给worker进程，从而实现对worker进程的控制。</p><p>2、worker 进程</p><p>工作进程，不断接收客户端的连接请求，处理请求。数量通常设置为与CPU核数一致，nginx也会将每个进程与每个CPU进行绑定，充分利用其多核特性。</p><blockquote><p>多个worker进程会竞争一个共享锁，只有抢到锁的进程才能处理客户端的请求。如果请求是accept事件，则会将其添加到accept队列中；如果是read或者write事件，则会将其添加到read-write队列。</p></blockquote><p><strong>可能有人问，OpenResty 为什么要基于 Nginx 框架？</strong></p><div align="left"><img src="'+o+'" width="300px"></div><p>主要还是看重了 Nginx 的高并发能力，反向代理服务器通常流量很大，本身不涉及复杂计算，属于I/O密集型服务。Nginx 采用基于 epoll 机制的事件驱动，异步非阻塞，大大提高并发处理能力。</p><p>但是 Nginx 采用 <code>C 语言</code> 开发，二次开发门槛较高。市场应用广泛，更多是基于 <code>nginx.conf</code> 预留配置参数，如：反向代理、负载均衡、静态web服务器，等</p><p>如果想让Nginx访问 MySQL ，定制化开发一些业务逻辑，难度很高。OpenResty 通过 嫁接方式，将 Nginx 和 Lua 脚本相结合，既保留 Nginx 高并发优势，也拥有脚本语言的开发效率，也大大降低了开发门槛。</p><p>Lua 是最快的、动态脚本语言，接近C语言运行速度。LuaJIT 将一些常用的lua函数和工具库预编译并缓存，下次调用时直接使用缓存的字节码，速度很快。</p><p>另外，Lua支持协程，这个很重要。</p><blockquote><p><strong>协程是用户态的操作，上下文切换不用涉及内核态，系统资源开销小；另外协程占用内存很小，初始 2KB</strong></p></blockquote><h2 id="openresty-核心架构" tabindex="-1"><a class="header-anchor" href="#openresty-核心架构"><span>OpenResty 核心架构</span></a></h2><p>OpenResty是一个基于Nginx的Web平台，内部嵌入<code>LuaJIT</code>虚拟机运行Lua脚本。使用 Lua 编程语言对 Nginx 核心以及各种 Nginx C 模块进行脚本编程。</p><div align="left"><img src="'+c+'" width="650px"></div><ul><li>每接到一个客户端请求，通过抢占锁，由一个worker进程来跟进处理</li><li>worker内部会创建一个lua协程，绑定请求，也就是说一个请求对应一个lua协程</li><li>lua协程将请求通过网络发出，并添加一个event事件到nginx。然后，当前协程就处于 <code>yield</code>，让出CPU控制权</li><li>当服务端响应数据后，网络流程会创建一个新的event事件，将之前的协程唤醒，将结果返回。</li></ul><blockquote><p>注意：不同的lua协程之间数据隔离，从而保证了不同的客户端请求不会相互影响。另外，一个worker中同一时刻，只会有一个协程在运行。</p></blockquote><div align="left"><img src="'+d+'" width="650px"></div><p>cosocket 将 Lua 协程 + Nginx 事件通知两个重要特性组合。</p><p>cosocket 是 OpenResty 世界中技术、实用价值最高部分。让我们可以用非常低廉的成本，优雅的姿势，比传统 socket 编程效率高好几倍的方式进行网络编程。无论资源占用、执行效率、并发能力都非常出色。</p><p><strong>为了方便开发，OpenResty 将一个 HTTP 请求划分为11个阶段，每个阶段有自己的专属职责。</strong></p><div align="left"><img src="'+h+'" width="650px"></div><p><strong>函数功能说明：</strong></p><ul><li>set_by_lua，用于设置变量</li><li>rewrite_by_lua，用于转发、重定向等</li><li>access_by_lua，用于准入、权限等</li><li>content_by_lua，用于生成返回内容</li><li>balancer_by_lua，负载均衡，路由转发</li><li>header_filter_by_lua，用于响应头过滤处理</li><li>body_filter_by_lua，用于响应体过滤处理</li><li>log_by_lua，日志记录</li></ul><p>OpenResty 提供了大量的 Lua API 接口，用于操作 Nginx 。只要熟悉lua语法，同时对 Nginx 的运行流程有较清楚理解，那么就可以轻松的在nginx上做二次开发。</p><p>无论是作为应用网关，还是高性能的web应用，支持连接各种丰富的后端存储，如：MySQL、Redis、Memcache、PostgreSQL 等，周边生态非常丰富。</p><div align="left"><img src="'+u+'" width="260px"></div><blockquote><p><a href="https://github.com/openresty/lua-nginx-module/#accessbylua" target="_blank" rel="noopener noreferrer">https://github.com/openresty/lua-nginx-module/#accessbylua</a></p></blockquote><p><strong>注意：OpenResty 的 API 有使用范围限制，每个 API 都有与之对应的使用阶段列表，如果你超范围使用就会报错。</strong></p><div align="left"><img src="'+b+`" width="650px"></div><h2 id="部署安装" tabindex="-1"><a class="header-anchor" href="#部署安装"><span>部署安装</span></a></h2><p>本文以 CentOS 系统中为例</p><p>1、添加 openresty 仓库，这样以后可以通过 <code>yum updata </code> 命令安装或更新我们的软件包</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>yum install yum-utils -y</span></span>
<span class="line"><span>yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>2、安装软件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>yum install openresty -y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>3、安装命令行工具 resty</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>yum install openresty-resty -y</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="项目实战" tabindex="-1"><a class="header-anchor" href="#项目实战"><span>项目实战</span></a></h2><p>1、修改nginx.conf配置文件</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>worker_processes  auto;</span></span>
<span class="line"><span>worker_rlimit_nofile 1000000;</span></span>
<span class="line"><span>events {</span></span>
<span class="line"><span>    use epoll;</span></span>
<span class="line"><span>    worker_connections  150000;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>http {</span></span>
<span class="line"><span>    include       mime.types;</span></span>
<span class="line"><span>    default_type  application/octet-stream;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span></span>
<span class="line"><span>                      &#39;$status $content_length $body_bytes_sent &quot;$http_referer&quot; &#39;</span></span>
<span class="line"><span>                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$upstream_response_time&quot; &quot;$request_time&quot;&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    access_log  logs/access.log  main;</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    server {</span></span>
<span class="line"><span>        listen 8080;</span></span>
<span class="line"><span>        location / {</span></span>
<span class="line"><span>            access_by_lua_block {</span></span>
<span class="line"><span>                local headers = ngx.req.get_headers(0)</span></span>
<span class="line"><span>                local trace_id= headers[&quot;X-Trace-Id&quot;]</span></span>
<span class="line"><span>                ngx.log(ngx.ERR, trace_id)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            #  ngx.say(&quot;&lt;p&gt;hello !&lt;/p&gt;&quot;)</span></span>
<span class="line"><span>            proxy_pass http://168.12.8.10:8080;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    server {</span></span>
<span class="line"><span>        listen 8082;</span></span>
<span class="line"><span>        location / {</span></span>
<span class="line"><span>            default_type text/html;</span></span>
<span class="line"><span>            content_by_lua_block {</span></span>
<span class="line"><span>                ngx.say(&quot;&lt;p&gt;Hello Openresty!&lt;/p&gt;&quot;)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>nginx.conf 内部分为三层嵌套：</p><ul><li>最外层的http，表示处理 HTTP 协议</li><li>http 内部 的 server 监听端口，会启动一个 LuaJIT 虚拟机，执行lua代码</li><li>同一个端口内部，区分不同的业务功能，采用 location 配置，通过不同的 path 路径，处理不同的业务逻辑。</li></ul><p>2、添加环境变量</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>echo &quot;export PATH=$PATH:/usr/local/openresty/nginx/sbin&quot; &gt;&gt; /etc/profile</span></span>
<span class="line"><span>source /etc/profile</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>3、启动 openresty，启动命令和nginx一致</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>nginx -c /usr/local/openresty/nginx/conf/nginx.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>4、访问 Web 服务</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>curl http://localhost:8082/</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果正常，浏览器页面会输出 Hello Openresty!</p><p>5、如果 nginx.conf 配置项做了修改，我们可以重新启动</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>nginx  -s reload</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li><a href="https://mp.weixin.qq.com/s/pSCtObwfr24Qv5RlKdiVZw" target="_blank" rel="noopener noreferrer">高性能网关设计实践</a></li><li><a href="https://mp.weixin.qq.com/s/xLpkHAden0qDEaAuqmn9dg" target="_blank" rel="noopener noreferrer">如何设计一个高性能网关</a></li><li><a href="https://zhuanlan.zhihu.com/p/31786017" target="_blank" rel="noopener noreferrer">浅谈微服务中的 API 网关（API Gateway）</a></li><li><a href="https://www.bilibili.com/video/BV1ag411L7Qb?from=search&amp;seid=14872072928161487010&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener noreferrer">第三百五十四讲|一节课搞懂 API 网关 openresty 的实现原理|要想微服务就要先搞定RPC</a></li><li><a href="https://tech.meituan.com/2021/05/20/shepherd-api-gateway.html" target="_blank" rel="noopener noreferrer">百亿规模API网关服务Shepherd的设计与实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/96757160" target="_blank" rel="noopener noreferrer">nginx master-worker进程工作原理</a></li><li><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx_lua/whats_cosocket.html" target="_blank" rel="noopener noreferrer">怎样理解 cosocket</a></li><li><a href="https://www.jianshu.com/p/3884cbd694b6" target="_blank" rel="noopener noreferrer">主流的微服务API网关性能比较</a></li><li><a href="http://dockone.io/article/8729" target="_blank" rel="noopener noreferrer">微服务五种开源API网关实现组件对比</a></li><li><a href="https://blog.crazytaxii.com/posts/openresty_nginx_basic/" target="_blank" rel="noopener noreferrer">OpenResty 中的 Nginx 基础知识</a></li><li><a href="https://www.cnblogs.com/wushuaishuai/p/9315611.html" target="_blank" rel="noopener noreferrer">CentOS安装OpenResty(Nginx+Lua)开发环境</a></li></ul>`,94)]))}const _=s(g,[["render",m]]),f=JSON.parse('{"path":"/posts/interview/arch/system/%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%20Openresty.html","title":"网关技术选型，为什么选择 Openresty ？事件驱动、协程...","lang":"zh-CN","frontmatter":{"title":"网关技术选型，为什么选择 Openresty ？事件驱动、协程...","description":"网关技术选型，为什么选择 Openresty ？事件驱动、协程... 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 互联网公司，不论体量大小如何，其内部的技术架构基本都是相似的，体现在以下几个方面： 数据量过大，如何定制化存储 访问量高了，如何集群化部署，流量负载均衡 响应速度慢了，如何提高...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/arch/system/%E7%BD%91%E5%85%B3%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%20Openresty.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"网关技术选型，为什么选择 Openresty ？事件驱动、协程..."}],["meta",{"property":"og:description","content":"网关技术选型，为什么选择 Openresty ？事件驱动、协程... 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 互联网公司，不论体量大小如何，其内部的技术架构基本都是相似的，体现在以下几个方面： 数据量过大，如何定制化存储 访问量高了，如何集群化部署，流量负载均衡 响应速度慢了，如何提高..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"网关技术选型，为什么选择 Openresty ？事件驱动、协程...\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":8.45,"words":2536},"filePathRelative":"posts/interview/arch/system/网关技术选型，为什么选择 Openresty.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>互联网公司，不论体量大小如何，其内部的技术架构基本都是相似的，体现在以下几个方面：</p>\\n<ul>\\n<li>数据量过大，如何定制化存储</li>\\n<li>访问量高了，如何集群化部署，流量负载均衡</li>\\n<li>响应速度慢了，如何提高处理速度，引入多级缓存</li>\\n<li>如果机器多了，如何保证某台服务器突然抽风，不影响业务集群的服务稳定性</li>\\n</ul>","autoDesc":true}');export{_ as comp,f as data};
