import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as o,o as t}from"./app-NomDibRt.js";const n="/vpress/images/middleware/mysql/4-1.jpg",a="/vpress/images/middleware/mysql/4-2.jpg",p="/vpress/images/middleware/mysql/4-3.jpg",r="/vpress/images/middleware/mysql/4-4.jpg",d="/vpress/images/middleware/mysql/4-5.jpg",l="/vpress/images/middleware/mysql/4-6.jpg",c={};function h(b,e){return t(),s("div",null,e[0]||(e[0]=[o('<h1 id="mysql-主备延迟有哪些坑-主备切换策略" tabindex="-1"><a class="header-anchor" href="#mysql-主备延迟有哪些坑-主备切换策略"><span>MySQL 主备延迟有哪些坑？主备切换策略</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>作为一名开发同学，大家对 MySQL 一定不陌生，像常见的 <code>事务特性</code>、<code>隔离级别</code> 、<code>索引</code>等也都是老生常谈。</p><p>今天，我们就来聊个深度话题，关于 MySQL 的 <code>高可用</code></p><h2 id="一、什么是高可用" tabindex="-1"><a class="header-anchor" href="#一、什么是高可用"><span>一、什么是高可用？</span></a></h2><p><strong>维基百科定义：</strong></p><blockquote><p>高可用性（high availability，缩写 HA），指系统无中断地执行其功能的能力，代表系统的可用性程度。高可用性通常通过提高系统的容错能力来实现。</p></blockquote><p><strong>MySQL 的高可用是如何实现的呢？</strong></p><p>首先，我们来看张图</p><div align="left"><img src="'+n+'" width="650px"></div><p>过程：</p><ul><li>开始时，处理流程主要是 <code>场景一</code></li><li>客户端<code>读、写</code>，访问的是主库</li><li>主库通过某种机制，将数据实时同步给备库</li><li>当主库突然发生故障（如：磁盘损坏等），无法正常响应客户端的请求。此时会<code>自动主备切换</code>，进入 <code>场景二</code></li><li>客户端读写，访问的是备库（此时备库升级为新主库）</li></ul><div align="left"><img src="'+a+'" width="260px"></div><p>看似天衣无缝，那是不是可以高枕无忧了呢？？？兄弟，想多了</p><p>主备切换，确实能满足高可用。但有个前提，主备库的数据要同步。</p><p>不过，<code>数据同步</code>是个异步操作，不可能做到实时，所以说<code>主备延迟</code>是一定存在的</p><h2 id="二、什么是主备延迟" tabindex="-1"><a class="header-anchor" href="#二、什么是主备延迟"><span>二、什么是主备延迟？</span></a></h2><div align="left"><img src="'+p+'" width="650px"></div><ul><li>主库完成一个事务，写入binlog。binlog 中有一个时间字段，用于记录主库写入的时间【时刻 t1】</li><li>binlog 同步给备库，备库接收并存储到中继日志 【时刻 t2】</li><li>备库SQL执行线程执行binlog，数据写入到备库表中 【时刻 t3】</li></ul><p>主备延迟时间计算公式：</p><blockquote><p>t3 - t1</p></blockquote><p>有没有简单命令，直接查看。在备库执行 <code>show slave status</code> 命令</p><blockquote><p>seconds_behind_master，表示当前备库延迟了多少秒</p></blockquote><p><strong>心细的同学会有疑问了， t3 和 t1 分属于两台机器，如果时钟不一致怎么办？</strong></p><p>初始化时，备库连接到主库，会执行 <code>SELECT UNIX_TIMESTAMP()</code> 来获得当前主库的系统时间。</p><p>如果发现主库的系统时间与备库不一致，备库在计算 <code>seconds_behind_master</code> 会自动减掉这个差值。</p><p>注意：</p><blockquote><p>binlog 数据传输的时间（t2 - t1）非常短，可以忽略。主要延迟花费在备库执行binlog日志</p></blockquote><h2 id="三、主备延迟-常见原因" tabindex="-1"><a class="header-anchor" href="#三、主备延迟-常见原因"><span>三、<code>主备延迟</code> 常见原因</span></a></h2><h3 id="_1、备库机器配置差" tabindex="-1"><a class="header-anchor" href="#_1、备库机器配置差"><span>1、备库机器配置差</span></a></h3><p>这个不难理解，“门当户对”、“志同道合”，如果主备机器的性能差别大，直接导致备库的同步速度跟不上主库的生产节奏。</p><p>就像跑步一样，落后差距会越来越大。</p><p>解决方案：</p><p>1、升级备库的机器配置</p><h3 id="_2、备库干私活" tabindex="-1"><a class="header-anchor" href="#_2、备库干私活"><span>2、备库干私活</span></a></h3><p>备库除了服务于正常的<code>读业务</code>外，是否有被其他特殊业务征用，如：运营数据统计等，这类操作非常消耗系统资源，也会影响数据同步速度。</p><p>解决方案：</p><p>可以借助大数据平台，数据异构，满足各种这些特殊的统计类查询。</p><h3 id="_3、大事务" tabindex="-1"><a class="header-anchor" href="#_3、大事务"><span>3、大事务</span></a></h3><p>我们知道 binglog 是在事务提交时才生成的。</p><p>如果是处理大事务，执行时间比较长（比如 5分钟）。虽然备库很快拿到 binlog，但是在<code>备库回放执行也要花费差不多的时间</code>，也要 5分钟 （备库中，只有这个事务执行完提交，备库才真正对外可见），从而导致主备延迟很大。</p><p>比如 delete 操作，慎用 <code>delete from 表名</code>，建议采用分批删除，减少大事务。</p><h2 id="四、主库不可用-主备切换有哪些策略" tabindex="-1"><a class="header-anchor" href="#四、主库不可用-主备切换有哪些策略"><span>四、主库不可用，主备切换有哪些策略？</span></a></h2><h3 id="_1、可靠优先" tabindex="-1"><a class="header-anchor" href="#_1、可靠优先"><span>1、可靠优先</span></a></h3><div align="left"><img src="'+r+'" width="650px"></div><p>当主库A 发生故障不可用时，开始进入主备切换</p><ul><li>首先，判断 B库 <code>seconds_behind_master</code> 是否小于设定的阈值（比如 4 秒），如果满足条件</li><li>将 A库 改为只读状态，将 readonly 设置为 true。断掉 A 库的写入操作，保证不会有新的写流量进来</li><li>判断 B库的 <code>seconds_behind_master</code> ，直到为 0</li><li>修改 B库 为 <code>读、写状态</code></li><li>客户端的请求打到 B库</li></ul><p>此时，主备切换完成。</p><p><strong>优点：</strong></p><p>数据不会丢失，所以我们称为可靠性高</p><p><strong>缺点：</strong></p><p>中间有个阶段，A库和B库都是只读状态，此时系统对外不能提供写服务。</p><h3 id="_2、可用优先" tabindex="-1"><a class="header-anchor" href="#_2、可用优先"><span>2、可用优先</span></a></h3><p>当然我们也可以不用等主备数据同步完成，在一开始时就直接将流量切到备库。</p><p>这样备库的流量就可能有两个来源：</p><ul><li>主库之前的剩余流量 binlog</li><li>客户端新请求进来的流量</li></ul><p>两部分流量冲击，会对 <code>数据一致性</code> 造成一些影响。</p><p><strong>我们来做个实验：</strong></p><p>首次创建一个用户表：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CREATE TABLE `person` (</span></span>\n<span class="line"><span>  `id`  bigint(20) unsigned  NOT NULL AUTO_INCREMENT,</span></span>\n<span class="line"><span>  `name` varchar(32) ,</span></span>\n<span class="line"><span>  PRIMARY KEY (`id`)</span></span>\n<span class="line"><span>) ENGINE=InnoDB;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入2条记录</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>insert into person(name) values (&quot;tom&quot;);</span></span>\n<span class="line"><span>insert into person(name) values (&quot;jerry&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>实验一：</strong></p><p>将 binlog 的格式设为 binlog_format=row</p><blockquote><p>说明： row 模式，写 binlog 时会记录所有字段的值</p></blockquote><div align="left"><img src="'+d+'" width="650px"></div><p>库A 、库B 在做数据同步时，都会报主键冲突，最后只有一行数据不一致，但是会丢数据。</p><p>优点：同步过程中，出现问题能够及时发现。</p><p><strong>实验二：</strong></p><p>将 binlog 格式设置为 <code>statement</code> 或者 <code>mixed</code></p><div align="left"><img src="'+l+'" width="650px"></div><p>按照 SQL 原始语句同步 binlog，可以看到，数据条数不会少，但是主键id会出现混乱。</p><p><strong>3、结论</strong></p><p>本着 &quot;攘外必先安内&quot; ，保证内部的数据的正确性是我们的首选。所以，一般建议大家选择 <code>可靠优先</code>。</p><p>但是可靠优先可能会导致一定时间内，数据库不可用。这个时间值取决于主备延迟的时间大小。</p><p>所以，我们应尽可能缩短主备库的延迟时间大小，这样一旦主库发生故障，备库才会更快的同步完数据，主备切换才能完成，服务才能更快恢复。</p>',76)]))}const u=i(c,[["render",h]]),_=JSON.parse('{"path":"/posts/interview/middleware/mysql/MySQL%20%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91%EF%BC%9F%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%AD%96%E7%95%A5.html","title":"MySQL 主备延迟有哪些坑？主备切换策略","lang":"zh-CN","frontmatter":{"title":"MySQL 主备延迟有哪些坑？主备切换策略","description":"MySQL 主备延迟有哪些坑？主备切换策略 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 作为一名开发同学，大家对 MySQL 一定不陌生，像常见的 事务特性、隔离级别 、索引等也都是老生常谈。 今天，我们就来聊个深度话题，关于 MySQL 的 高可用 一、什么是高可用？ 维基百科定义： 高...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/middleware/mysql/MySQL%20%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9D%91%EF%BC%9F%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"MySQL 主备延迟有哪些坑？主备切换策略"}],["meta",{"property":"og:description","content":"MySQL 主备延迟有哪些坑？主备切换策略 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 作为一名开发同学，大家对 MySQL 一定不陌生，像常见的 事务特性、隔离级别 、索引等也都是老生常谈。 今天，我们就来聊个深度话题，关于 MySQL 的 高可用 一、什么是高可用？ 维基百科定义： 高..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL 主备延迟有哪些坑？主备切换策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":5.41,"words":1622},"filePathRelative":"posts/interview/middleware/mysql/MySQL 主备延迟有哪些坑？主备切换策略.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>作为一名开发同学，大家对 MySQL 一定不陌生，像常见的 <code>事务特性</code>、<code>隔离级别</code> 、<code>索引</code>等也都是老生常谈。</p>\\n<p>今天，我们就来聊个深度话题，关于 MySQL 的 <code>高可用</code></p>","autoDesc":true}');export{u as comp,_ as data};
