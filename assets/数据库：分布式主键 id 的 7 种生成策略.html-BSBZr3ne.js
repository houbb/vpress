import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,a as i,o as r}from"./app-NomDibRt.js";const p="/vpress/images/pay/arch/15-1.png",a={};function n(s,t){return r(),o("div",null,t[0]||(t[0]=[i('<h1 id="数据库-分布式主键-id-的-7-种生成策略" tabindex="-1"><a class="header-anchor" href="#数据库-分布式主键-id-的-7-种生成策略"><span>数据库：分布式主键 id 的 7 种生成策略</span></a></h1><blockquote><p>作者：老马<br><br>公众号：老马啸西风<br><br> 博客：<a href="https://houbb.github.io/" target="_blank" rel="noopener noreferrer">https://houbb.github.io/</a><br><br> 人生理念：知行合一</p></blockquote><p>当面对海量数据存储时，我们常用的技术方案就是分库分表，这里面有个关键问题：<strong>「主键 id 要如何生成？」</strong></p><p>之前我们玩单表时，直接借助 MySQL 存储引擎自动生成</p><div align="left"><img src="'+p+'" width="450px"></div><p>现在分表后，如果每个表的id 还是从 1 开始自增生成，虽然数据分布在不同的库中，但id是相同的，这个对上层的业务来说肯定是无法接受的，我们需要一个全局唯一的id</p><blockquote><p>就像软件架构讲究高内聚、低耦合，不同团队合作时，我们只关心系统对接层面的规范，至于系统内部如何实现，外部并不关心。<br> 数据量太大一样，单表存储不了，要引入分表，至于分多少表，或者采用 NoSQL 介质存储，上层的业务调用方并不关心，他们关心的是通过 RPC 接口根据不同的查询条件可以获取到数据。<br> 大家都是各司其职，做好自己分内的专业事情。</p></blockquote><p><strong>那分布式主键id 需要具备哪些特点：</strong></p><ul><li>全局唯一性：这个是最基本的要求，不能出现重复 id</li><li>高性能：响应速度一定要快，否则很容易成为业务瓶颈</li><li>高可用：由于处于流程的关键节点，如果服务挂了，会阻塞整个流程，要主备部署，保证其高可用</li><li>方便性：业务单一，接入系统不要太过复杂，最好能开箱即用，引入一个jar包，简单配置一下即可</li></ul><p>讲了这么多，知道不能使用数据库自增主键id 了，还提了这么多实现要求，该怎么办，问题总是要解决的</p>',10)]))}const c=e(a,[["render",n]]),h=JSON.parse('{"path":"/posts/interview/pay/arch/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%20id%20%E7%9A%84%207%20%E7%A7%8D%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5.html","title":"数据库：分布式主键 id 的 7 种生成策略","lang":"zh-CN","frontmatter":{"title":"数据库：分布式主键 id 的 7 种生成策略","pay":"https://articles.zsxq.com/id_89g8dm1ku36b.html","description":"数据库：分布式主键 id 的 7 种生成策略 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 当面对海量数据存储时，我们常用的技术方案就是分库分表，这里面有个关键问题：「主键 id 要如何生成？」 之前我们玩单表时，直接借助 MySQL 存储引擎自动生成 现在分表后，如果每个表的id 还是从 ...","head":[["meta",{"property":"og:url","content":"https://houbb.github.io/vpress/posts/interview/pay/arch/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%20id%20%E7%9A%84%207%20%E7%A7%8D%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5.html"}],["meta",{"property":"og:site_name","content":"老马啸西风"}],["meta",{"property":"og:title","content":"数据库：分布式主键 id 的 7 种生成策略"}],["meta",{"property":"og:description","content":"数据库：分布式主键 id 的 7 种生成策略 作者：老马 公众号：老马啸西风 博客：https://houbb.github.io/ 人生理念：知行合一 当面对海量数据存储时，我们常用的技术方案就是分库分表，这里面有个关键问题：「主键 id 要如何生成？」 之前我们玩单表时，直接借助 MySQL 存储引擎自动生成 现在分表后，如果每个表的id 还是从 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-30T09:38:40.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-30T09:38:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据库：分布式主键 id 的 7 种生成策略\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-03-30T09:38:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"老马啸西风\\",\\"url\\":\\"https://houbb.github.io\\"}]}"]]},"git":{"createdTime":1743327520000,"updatedTime":1743327520000,"contributors":[{"name":"houbb","username":"houbb","email":"houbinbin.echo@gmail.com","commits":1,"url":"https://github.com/houbb"}]},"readingTime":{"minutes":1.75,"words":526},"filePathRelative":"posts/interview/pay/arch/数据库：分布式主键 id 的 7 种生成策略.md","localizedDate":"2025年3月30日","excerpt":"\\n<blockquote>\\n<p>作者：老马<br>\\n<br>公众号：老马啸西风<br>\\n<br> 博客：<a href=\\"https://houbb.github.io/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://houbb.github.io/</a><br>\\n<br> 人生理念：知行合一</p>\\n</blockquote>\\n<p>当面对海量数据存储时，我们常用的技术方案就是分库分表，这里面有个关键问题：<strong>「主键 id 要如何生成？」</strong></p>\\n<p>之前我们玩单表时，直接借助 MySQL 存储引擎自动生成</p>","autoDesc":true}');export{c as comp,h as data};
